-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "API.chs" #-}{-# LANGUAGE Arrows,
             BangPatterns,
             ConstraintKinds,
             DeriveDataTypeable,
             EmptyDataDecls,
             FlexibleContexts,
             FlexibleInstances, ForeignFunctionInterface,
             FunctionalDependencies,
             GADTs,
             GeneralizedNewtypeDeriving,
             ImpredicativeTypes,
             MultiParamTypeClasses,
             NamedFieldPuns,
             NoMonomorphismRestriction,
             RankNTypes,
             ScopedTypeVariables,
             StandaloneDeriving,
             TemplateHaskell,
             TupleSections,
             TypeFamilies,
             TypeOperators,
             TypeSynonymInstances,
             ViewPatterns #-}

-- | This module provides an API to control the CEGIS synthesis backend.
module CegisCApi.API (
    -- * Types
    BNType (..),
    NodeVector,
    BoolNodePtr,
    BooleanDAGPtr,
    CommandLineArgs,
    InterpreterEnvironment,
    -- * API
    -- ** Initialize the command line
    cmdline_args,
    cl_get_in_name,
    cl_set_in_name,
    cl_get_out_name,
    cl_set_verbosity,
    cl_set_global_params,
    -- ** Start running the backend
    runDriver,
    getEnvt,
    -- ** Core synthesis commands
    evt_get_copy,
    evt_prepare_miter,
    evt_assert_dag,
    evt_is_ready,
    evt_check_ready,
    evt_print_controls,
    evt_get_controls,
    -- ** Manipulating the DAG
    bdag_get_nodes_by_type,
    bdag_new,
    bdag_clone,
    bn_is_minimize,
    bn_get_name,
    bn_new,
    bn_clone,
    bn_set_const,

    -- *** Sugar
    -- | Example:
    --
    -- @
    --  withDag dag $ do
    --      y <- e_const v
    --      lt_node <- e_lt x y
    --      e_assert lt_node
    -- @
    bn_new_const,
    bn_assert,
    e_const,
    e_lt,
    e_eq,
    e_assert,
    withDag,

    -- * Re-exported stuff
    nullPtr
    ) where

import Prelude hiding (id, (.))
import Control.Arrow
import Control.Applicative
import Control.Category
import Control.Monad
import Control.Monad.Trans.Class
import Control.Monad.Trans.Reader

import qualified Data.Map as Map
import qualified Data.List.HT as HT

import Text.Printf

import Foreign.C.String
import Foreign.C.Types
import Foreign.Marshal.Alloc
import Foreign.Marshal.Array
import Foreign.Marshal.Utils
import Foreign.Ptr
import Foreign.Storable


{-# LINE 105 "API.chs" #-}
data BoolNode
data BooleanDAG

-- | Reference to a Boolean DAG node. Its memory is
-- managed by the Boolean DAG
type BoolNodePtr = Ptr (BoolNode)
{-# LINE 111 "API.chs" #-}

newtype NodeVector = NodeVector (Ptr (NodeVector))
{-# LINE 113 "API.chs" #-}

-- | Reference to a Boolean DAG. Boolean DAG's are self-contained,
-- but their control values are statically stored by an
-- InterpreterEnvironment (I think; Armando: correct me if I'm wrong).
type BooleanDAGPtr = Ptr (BooleanDAG)
{-# LINE 118 "API.chs" #-}

-- | Contains a lot of global settings (verbosity, etc.).
-- Make sure to initialize it (via 'cmdline_args')
-- before you do anything else.
newtype CommandLineArgs = CommandLineArgs (Ptr (CommandLineArgs))
{-# LINE 123 "API.chs" #-}

-- | Manages the 2QBF synthesis problem.
newtype InterpreterEnvironment = InterpreterEnvironment (Ptr (InterpreterEnvironment))
{-# LINE 126 "API.chs" #-}

data BNType = BnAnd
            | BnOr
            | BnXor
            | BnSrc
            | BnDst
            | BnNot
            | BnCtrl
            | BnPlus
            | BnTimes
            | BnDiv
            | BnMod
            | BnNeg
            | BnConst
            | BnGt
            | BnGe
            | BnLt
            | BnLe
            | BnEq
            | BnAssert
            | BnArracc
            | BnUfun
            | BnArrass
            | BnActrl
            | BnArrR
            | BnArrW
            | BnArrCreate
            deriving (Enum,Show,Eq)

{-# LINE 128 "API.chs" #-}



{- Marshaling functions -}
fromEnum' = fromIntegral . fromEnum

cStringArray :: [String] -> IO (Ptr CString)
cStringArray = newArray <=< mapM newCString

fromCStringArray :: Integral a => a -> Ptr CString -> IO [String]
fromCStringArray (fromInteger . toInteger -> n) ptr = do
    mapM peekCAString =<< peekArray (fromInteger . toInteger $ n) ptr

fromCIntArray :: Integral a => a -> Ptr CInt -> IO [Int]
fromCIntArray (fromInteger . toInteger -> n) ptr = do
    map (fromInteger . toInteger) <$> peekArray n ptr

-- for some reason, can't type "with" into c2hs blocks
withT = with


-- marshalling vectors
unpackNodeVec :: NodeVector -> IO [BoolNodePtr]
unpackNodeVec nv = do
    l <- node_vec_size nv
    forM [0..l - 1] (node_vec_get nv)
node_vec_size :: NodeVector -> IO (Int)
node_vec_size a1 =
  let {a1' = id a1} in 
  node_vec_size'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 155 "API.chs" #-}
node_vec_get :: NodeVector -> Int -> IO (BoolNodePtr)
node_vec_get a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  node_vec_get'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 156 "API.chs" #-}



-- | You probably want to run this function first.
--   Pass it an array of arguments, like
--
-- > cmdline_args [ "--verbosity", "5", "infile", "outfile" ]
cmdline_args :: [String] -> IO CommandLineArgs
cmdline_args x = do
    res <- cmdline_args_ (length x) =<< cStringArray x
    res <$ cl_set_global_params res

-- helpers
cmdline_args_ :: Int -> (Ptr CString) -> IO (CommandLineArgs)
cmdline_args_ a1 a2 =
  let {a1' = fromIntegral a1} in 
  let {a2' = id a2} in 
  cmdline_args_'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 171 "API.chs" #-}
cl_set_global_params :: CommandLineArgs -> IO ()
cl_set_global_params a1 =
  let {a1' = id a1} in 
  cl_set_global_params'_ a1' >>= \res ->
  return ()
{-# LINE 173 "API.chs" #-}

-- | Get the input filename, as parsed by cegis command line handler.
cl_get_in_name :: CommandLineArgs -> IO (String)
cl_get_in_name a1 =
  let {a1' = id a1} in 
  cl_get_in_name'_ a1' >>= \res ->
  peekCAString res >>= \res' ->
  return (res')
{-# LINE 177 "API.chs" #-}

cl_set_in_name :: CommandLineArgs -> String -> IO ()
cl_set_in_name a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  cl_set_in_name'_ a1' a2' >>= \res ->
  return ()
{-# LINE 181 "API.chs" #-}

-- | Get the output filename, as parsed by cegis command line handler.
cl_get_out_name :: CommandLineArgs -> IO (String)
cl_get_out_name a1 =
  let {a1' = id a1} in 
  cl_get_out_name'_ a1' >>= \res ->
  peekCAString res >>= \res' ->
  return (res')
{-# LINE 185 "API.chs" #-}

-- | Set the verbosity; 5 is very verbose, -1 should print nearly nothing
cl_set_verbosity :: CommandLineArgs -> Int -> IO ()
cl_set_verbosity a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  cl_set_verbosity'_ a1' a2' >>= \res ->
  return ()
{-# LINE 190 "API.chs" #-}



-- | Call this after 'cmdline_args'. Reads a program from the input filename,
-- creates a DAG (circuit representation), and starts solving if there are
-- any \"assert ... SKETCHES ...;\" lines present.
runDriver :: IO ()
runDriver =
  runDriver'_ >>= \res ->
  return ()
{-# LINE 197 "API.chs" #-}

-- | Get the C-global environment generated by 'runDriver'.
getEnvt :: IO (InterpreterEnvironment)
getEnvt =
  getEnvt'_ >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 200 "API.chs" #-}

-- | Get a copy of a function's DAG.
evt_get_copy :: InterpreterEnvironment -> String -> IO (BooleanDAGPtr)
evt_get_copy a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  evt_get_copy'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 205 "API.chs" #-}

-- | DAG representing the assertion \"forall in. spec(in) == sketch(in)\". Arguments:
--
-- > evt_prepare_miter spec sketch
evt_prepare_miter :: InterpreterEnvironment -> BooleanDAGPtr -> BooleanDAGPtr -> IO (BooleanDAGPtr)
evt_prepare_miter a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = id a3} in 
  evt_prepare_miter'_ a1' a2' a3' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 213 "API.chs" #-}

-- | Solves a DAG. Usually this DAG is the output of 'evt_prepare_miter'.
evt_assert_dag :: InterpreterEnvironment -> BooleanDAGPtr -> IO (Int)
evt_assert_dag a1 a2 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  evt_assert_dag'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 217 "API.chs" #-}

-- | Returns if the sketch has a valid solution (write it out with 'evt_print_controls').
evt_is_ready :: InterpreterEnvironment -> IO (Bool)
evt_is_ready a1 =
  let {a1' = id a1} in 
  evt_is_ready'_ a1' >>= \res ->
  let {res' = toBool res} in
  return (res')
{-# LINE 221 "API.chs" #-}

-- | Throws an error if the environment is not ready.
evt_check_ready :: InterpreterEnvironment -> IO InterpreterEnvironment
evt_check_ready ie = go <$> evt_is_ready ie where
    go False = error "Could not resolve sketch."
    go True = ie

-- | Write the current solutions to a file (argument: filename).
evt_print_controls :: InterpreterEnvironment -> String -> IO ()
evt_print_controls a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  evt_print_controls'_ a1' a2' >>= \res ->
  return ()
{-# LINE 232 "API.chs" #-}

evt_get_controls_ :: InterpreterEnvironment -> IO (CInt, Ptr (CString), Ptr CInt)
evt_get_controls_ a1 =
  let {a1' = id a1} in 
  alloca $ \a2' -> 
  alloca $ \a3' -> 
  alloca $ \a4' -> 
  evt_get_controls_'_ a1' a2' a3' a4' >>= \res ->
  peek  a2'>>= \a2'' -> 
  peek  a3'>>= \a3'' -> 
  peek  a4'>>= \a4'' -> 
  return (a2'', a3'', a4'')
{-# LINE 238 "API.chs" #-}

-- | Get the current solution, as a map from hole names to values.
-- Use Map.toList if you want to print / iterate over all of them.
evt_get_controls
  :: InterpreterEnvironment -> IO (Map.Map String Int)
evt_get_controls evt = do
    (n, keys, val) <- evt_get_controls_ evt
    let n' :: Int = fromInteger . toInteger $ n
    keys' <- fromCStringArray n keys
    val' :: [Int] <- fromCIntArray n val
    return $ Map.fromList [(keys' !! i, val' !! i) | i <- [0..(n' - 1)]]
    -- return Map.fromList [





-- | Get a list of all nodes of a particular type from the tree.
bdag_get_nodes_by_type :: BooleanDAGPtr -> BNType -> IO ([BoolNodePtr])
bdag_get_nodes_by_type a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromEnum' a2} in 
  bdag_get_nodes_by_type'_ a1' a2' >>= \res ->
  unpackNodeVec res >>= \res' ->
  return (res')
{-# LINE 258 "API.chs" #-}

-- | Creates a new BooleanDAG.
bdag_new :: IO (BooleanDAGPtr)
bdag_new =
  bdag_new'_ >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 262 "API.chs" #-}

bdag_clone :: BooleanDAGPtr -> IO (BooleanDAGPtr)
bdag_clone a1 =
  let {a1' = id a1} in 
  bdag_clone'_ a1' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 265 "API.chs" #-}



-- | Determine whether a control node (star) should be minimized.
bn_is_minimize :: BoolNodePtr -> IO (Bool)
bn_is_minimize a1 =
  let {a1' = id a1} in 
  bn_is_minimize'_ a1' >>= \res ->
  let {res' = toBool res} in
  return (res')
{-# LINE 270 "API.chs" #-}

-- | Get the name of a node.
bn_get_name :: BoolNodePtr -> IO (String)
bn_get_name a1 =
  let {a1' = id a1} in 
  bn_get_name'_ a1' >>= \res ->
  peekCAString res >>= \res' ->
  return (res')
{-# LINE 273 "API.chs" #-}

bn_clone :: BoolNodePtr -> Bool -> IO (BoolNodePtr)
bn_clone a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromBool a2} in 
  bn_clone'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 277 "API.chs" #-}

-- | Create a new node. Arguments: DAG (required), mother (can be
-- nullPtr), father (can be nullPtr), and type (required).
bn_new :: BooleanDAGPtr -> BoolNodePtr -> BoolNodePtr -> BNType -> IO (BoolNodePtr)
bn_new a1 a2 a3 a4 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = id a3} in 
  let {a4' = fromEnum' a4} in 
  bn_new'_ a1' a2' a3' a4' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 285 "API.chs" #-}

-- | Set the value of a 'BnConst' node.
bn_set_const :: BoolNodePtr -> Int -> IO ()
bn_set_const a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  bn_set_const'_ a1' a2' >>= \res ->
  return ()
{-# LINE 290 "API.chs" #-}

-- | Convenience -- runs 'bn_new', then 'bn_set_const'
bn_new_const dag v = do
    n <- bn_new dag nullPtr nullPtr BnConst
    n <$ bn_set_const n v

-- | Convenience -- assert a boolean node
bn_assert dag n = bn_new dag n nullPtr BnAssert

e_const v = do
    dag <- ask
    lift $ bn_new_const dag v

e_binary t x y = do
    dag <- ask
    lift $ bn_new dag x y t

e_lt = e_binary BnLt
e_eq = e_binary BnEq

e_assert n = do
    dag <- ask
    lift $ bn_assert dag n

withDag = flip runReaderT

foreign import ccall safe "API.chs.h node_vec_size"
  node_vec_size'_ :: ((NodeVector) -> (IO CInt))

foreign import ccall safe "API.chs.h node_vec_get"
  node_vec_get'_ :: ((NodeVector) -> (CInt -> (IO (BoolNodePtr))))

foreign import ccall safe "API.chs.h cmdline_args"
  cmdline_args_'_ :: (CInt -> ((Ptr (Ptr CChar)) -> (IO (CommandLineArgs))))

foreign import ccall safe "API.chs.h cl_set_global_params"
  cl_set_global_params'_ :: ((CommandLineArgs) -> (IO ()))

foreign import ccall safe "API.chs.h cl_get_in_name"
  cl_get_in_name'_ :: ((CommandLineArgs) -> (IO (Ptr CChar)))

foreign import ccall safe "API.chs.h cl_set_in_name"
  cl_set_in_name'_ :: ((CommandLineArgs) -> ((Ptr CChar) -> (IO ())))

foreign import ccall safe "API.chs.h cl_get_out_name"
  cl_get_out_name'_ :: ((CommandLineArgs) -> (IO (Ptr CChar)))

foreign import ccall safe "API.chs.h cl_set_verbosity"
  cl_set_verbosity'_ :: ((CommandLineArgs) -> (CInt -> (IO ())))

foreign import ccall safe "API.chs.h runDriver"
  runDriver'_ :: (IO ())

foreign import ccall safe "API.chs.h getEnvt"
  getEnvt'_ :: (IO (InterpreterEnvironment))

foreign import ccall safe "API.chs.h evt_get_copy"
  evt_get_copy'_ :: ((InterpreterEnvironment) -> ((Ptr CChar) -> (IO (BooleanDAGPtr))))

foreign import ccall safe "API.chs.h evt_prepare_miter"
  evt_prepare_miter'_ :: ((InterpreterEnvironment) -> ((BooleanDAGPtr) -> ((BooleanDAGPtr) -> (IO (BooleanDAGPtr)))))

foreign import ccall safe "API.chs.h evt_assert_dag"
  evt_assert_dag'_ :: ((InterpreterEnvironment) -> ((BooleanDAGPtr) -> (IO CInt)))

foreign import ccall safe "API.chs.h evt_is_ready"
  evt_is_ready'_ :: ((InterpreterEnvironment) -> (IO CInt))

foreign import ccall safe "API.chs.h evt_print_controls"
  evt_print_controls'_ :: ((InterpreterEnvironment) -> ((Ptr CChar) -> (IO ())))

foreign import ccall safe "API.chs.h evt_get_controls"
  evt_get_controls_'_ :: ((InterpreterEnvironment) -> ((Ptr CInt) -> ((Ptr (Ptr (Ptr CChar))) -> ((Ptr (Ptr CInt)) -> (IO ())))))

foreign import ccall safe "API.chs.h bdag_get_nodes_by_type"
  bdag_get_nodes_by_type'_ :: ((BooleanDAGPtr) -> (CInt -> (IO (NodeVector))))

foreign import ccall safe "API.chs.h bdag_new"
  bdag_new'_ :: (IO (BooleanDAGPtr))

foreign import ccall safe "API.chs.h bdag_clone"
  bdag_clone'_ :: ((BooleanDAGPtr) -> (IO (BooleanDAGPtr)))

foreign import ccall safe "API.chs.h bn_is_minimize"
  bn_is_minimize'_ :: ((BoolNodePtr) -> (IO CInt))

foreign import ccall safe "API.chs.h bn_get_name"
  bn_get_name'_ :: ((BoolNodePtr) -> (IO (Ptr CChar)))

foreign import ccall safe "API.chs.h bn_clone"
  bn_clone'_ :: ((BoolNodePtr) -> (CInt -> (IO (BoolNodePtr))))

foreign import ccall safe "API.chs.h bn_new"
  bn_new'_ :: ((BooleanDAGPtr) -> ((BoolNodePtr) -> ((BoolNodePtr) -> (CInt -> (IO (BoolNodePtr))))))

foreign import ccall safe "API.chs.h bn_set_const"
  bn_set_const'_ :: ((BoolNodePtr) -> (CInt -> (IO ())))
