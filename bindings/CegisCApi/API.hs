-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "API.chs" #-}{-# LANGUAGE Arrows,
             BangPatterns,
             ConstraintKinds,
             DeriveDataTypeable,
             EmptyDataDecls,
             FlexibleContexts,
             FlexibleInstances, ForeignFunctionInterface,
             FunctionalDependencies,
             GADTs,
             GeneralizedNewtypeDeriving,
             ImpredicativeTypes,
             MultiParamTypeClasses,
             NamedFieldPuns,
             NoMonomorphismRestriction,
             RankNTypes,
             ScopedTypeVariables,
             StandaloneDeriving,
             TemplateHaskell,
             TupleSections,
             TypeFamilies,
             TypeOperators,
             TypeSynonymInstances,
             ViewPatterns #-}

module CegisCApi.API (
    -- * Types
    BNType (..),
    BoolNode,
    NodeVector,
    BooleanDAG,
    CommandLineArgs,
    InterpreterEnvironment,
    -- * API
    -- ** Initialize the command line
    cmdline_args,
    cl_get_in_name,
    cl_set_in_name,
    cl_get_out_name,
    cl_set_verbosity,
    cl_set_global_params,
    -- ** Start running the backend
    runDriver,
    getEnvt,
    -- ** Core synthesis commands
    evt_get_copy,
    evt_prepare_miter,
    evt_assert_dag,
    evt_is_ready,
    evt_check_ready,
    evt_print_controls,
    -- ** Manipulating the DAG
    bdag_get_nodes_by_type,
    bn_is_minimize
    ) where

import Prelude hiding (id, (.))
import Control.Arrow
import Control.Applicative
import Control.Category
import Control.Monad
import Control.Monad.Trans.Class

import qualified Data.List.HT as HT

import Text.Printf

import Foreign.Marshal.Array
import Foreign.Ptr
import Foreign.C.String
import Foreign.C.Types


{-# LINE 72 "API.chs" #-}
newtype BoolNode = BoolNode (Ptr (BoolNode))
{-# LINE 73 "API.chs" #-}
newtype NodeVector = NodeVector (Ptr (NodeVector))
{-# LINE 74 "API.chs" #-}
newtype BooleanDAG = BooleanDAG (Ptr (BooleanDAG))
{-# LINE 75 "API.chs" #-}
newtype CommandLineArgs = CommandLineArgs (Ptr (CommandLineArgs))
{-# LINE 76 "API.chs" #-}
newtype InterpreterEnvironment = InterpreterEnvironment (Ptr (InterpreterEnvironment))
{-# LINE 77 "API.chs" #-}
data BNType = BnAnd
            | BnOr
            | BnXor
            | BnSrc
            | BnDst
            | BnNot
            | BnCtrl
            | BnPlus
            | BnTimes
            | BnDiv
            | BnMod
            | BnNeg
            | BnConst
            | BnGt
            | BnGe
            | BnLt
            | BnLe
            | BnEq
            | BnAssert
            | BnArracc
            | BnUfun
            | BnArrass
            | BnActrl
            deriving (Enum,Show,Eq)

{-# LINE 78 "API.chs" #-}



{- Marshaling functions -}
fromEnum' = fromIntegral . fromEnum
toBool = (/= 0)

cStringArray :: [String] -> IO (Ptr CString)
cStringArray = newArray <=< mapM newCString




-- | You probably want to run this function first.
--   Pass it an array of arguments, like
--
-- > cmdline_args [ "--verbosity", "5", "infile", "outfile" ]
cmdline_args :: [String] -> IO CommandLineArgs
cmdline_args x = do
    res <- cmdline_args_ (length x) =<< cStringArray x
    res <$ cl_set_global_params res

-- helpers
cmdline_args_ :: Int -> (Ptr CString) -> IO (CommandLineArgs)
cmdline_args_ a1 a2 =
  let {a1' = fromIntegral a1} in 
  let {a2' = id a2} in 
  cmdline_args_'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 103 "API.chs" #-}
cl_set_global_params :: CommandLineArgs -> IO ()
cl_set_global_params a1 =
  let {a1' = id a1} in 
  cl_set_global_params'_ a1' >>= \res ->
  return ()
{-# LINE 105 "API.chs" #-}

-- | Get the input filename, as parsed by cegis command line handler.
cl_get_in_name :: CommandLineArgs -> IO (String)
cl_get_in_name a1 =
  let {a1' = id a1} in 
  cl_get_in_name'_ a1' >>= \res ->
  peekCAString res >>= \res' ->
  return (res')
{-# LINE 108 "API.chs" #-}

cl_set_in_name :: CommandLineArgs -> String -> IO ()
cl_set_in_name a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  cl_set_in_name'_ a1' a2' >>= \res ->
  return ()
{-# LINE 110 "API.chs" #-}

-- | Get the output filename, as parsed by cegis command line handler.
cl_get_out_name :: CommandLineArgs -> IO (String)
cl_get_out_name a1 =
  let {a1' = id a1} in 
  cl_get_out_name'_ a1' >>= \res ->
  peekCAString res >>= \res' ->
  return (res')
{-# LINE 113 "API.chs" #-}

-- | Set the verbosity; 5 is very verbose, -1 should print nearly nothing
cl_set_verbosity :: CommandLineArgs -> Int -> IO ()
cl_set_verbosity a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  cl_set_verbosity'_ a1' a2' >>= \res ->
  return ()
{-# LINE 116 "API.chs" #-}



-- | Call this after 'cmdline_args'. Reads a program from the input filename,
-- creates a DAG (circuit representation), and starts solving if there are
-- any \"assert ... SKETCHES ...;\" lines present.
runDriver :: IO ()
runDriver =
  runDriver'_ >>= \res ->
  return ()
{-# LINE 123 "API.chs" #-}

-- | Get the C-global environment generated by 'runDriver'
getEnvt :: IO (InterpreterEnvironment)
getEnvt =
  getEnvt'_ >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 126 "API.chs" #-}

-- | Get a copy of a function's DAG
evt_get_copy :: InterpreterEnvironment -> String -> IO (BooleanDAG)
evt_get_copy a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  evt_get_copy'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 129 "API.chs" #-}

-- | DAG representing the assertion \"forall in. spec(in) == sketch(in)\". Arguments:
--
-- > evt_prepare_miter spec sketch
evt_prepare_miter :: InterpreterEnvironment -> BooleanDAG -> BooleanDAG -> IO (BooleanDAG)
evt_prepare_miter a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = id a3} in 
  evt_prepare_miter'_ a1' a2' a3' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 136 "API.chs" #-}

-- | Solves a DAG, usually the output of 'evt_prepare_miter'
evt_assert_dag :: InterpreterEnvironment -> BooleanDAG -> IO (Int)
evt_assert_dag a1 a2 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  evt_assert_dag'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 140 "API.chs" #-}

-- | Returns if the sketch has a valid solution (write it out with 'evt_print_controls')
evt_is_ready :: InterpreterEnvironment -> IO (Bool)
evt_is_ready a1 =
  let {a1' = id a1} in 
  evt_is_ready'_ a1' >>= \res ->
  let {res' = toBool res} in
  return (res')
{-# LINE 143 "API.chs" #-}

-- | Throws an error if the environment is not ready
evt_check_ready :: InterpreterEnvironment -> IO InterpreterEnvironment
evt_check_ready ie = go <$> evt_is_ready ie where
    go False = error "Could not resolve sketch."
    go True = ie

-- | Write the current solutions to a filename
evt_print_controls :: InterpreterEnvironment -> String -> IO ()
evt_print_controls a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  evt_print_controls'_ a1' a2' >>= \res ->
  return ()
{-# LINE 153 "API.chs" #-}



-- marshalling vectors
unpackNodeVec :: NodeVector -> IO [BoolNode]
unpackNodeVec nv = do
    l <- node_vec_size nv
    forM [0..l - 1] (node_vec_get nv)
node_vec_size :: NodeVector -> IO (Int)
node_vec_size a1 =
  let {a1' = id a1} in 
  node_vec_size'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 162 "API.chs" #-}
node_vec_get :: NodeVector -> Int -> IO (BoolNode)
node_vec_get a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  node_vec_get'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 163 "API.chs" #-}

-- | Get a list of all nodes of a particular type from the tree
bdag_get_nodes_by_type :: BooleanDAG -> BNType -> IO ([BoolNode])
bdag_get_nodes_by_type a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromEnum' a2} in 
  bdag_get_nodes_by_type'_ a1' a2' >>= \res ->
  unpackNodeVec res >>= \res' ->
  return (res')
{-# LINE 167 "API.chs" #-}

-- | Determine whether a control node (star) should be minimized
bn_is_minimize :: BoolNode -> IO (Bool)
bn_is_minimize a1 =
  let {a1' = id a1} in 
  bn_is_minimize'_ a1' >>= \res ->
  let {res' = toBool res} in
  return (res')
{-# LINE 170 "API.chs" #-}


foreign import ccall safe "API.chs.h cmdline_args"
  cmdline_args_'_ :: (CInt -> ((Ptr (Ptr CChar)) -> (IO (CommandLineArgs))))

foreign import ccall safe "API.chs.h cl_set_global_params"
  cl_set_global_params'_ :: ((CommandLineArgs) -> (IO ()))

foreign import ccall safe "API.chs.h cl_get_in_name"
  cl_get_in_name'_ :: ((CommandLineArgs) -> (IO (Ptr CChar)))

foreign import ccall safe "API.chs.h cl_set_in_name"
  cl_set_in_name'_ :: ((CommandLineArgs) -> ((Ptr CChar) -> (IO ())))

foreign import ccall safe "API.chs.h cl_get_out_name"
  cl_get_out_name'_ :: ((CommandLineArgs) -> (IO (Ptr CChar)))

foreign import ccall safe "API.chs.h cl_set_verbosity"
  cl_set_verbosity'_ :: ((CommandLineArgs) -> (CInt -> (IO ())))

foreign import ccall safe "API.chs.h runDriver"
  runDriver'_ :: (IO ())

foreign import ccall safe "API.chs.h getEnvt"
  getEnvt'_ :: (IO (InterpreterEnvironment))

foreign import ccall safe "API.chs.h evt_get_copy"
  evt_get_copy'_ :: ((InterpreterEnvironment) -> ((Ptr CChar) -> (IO (BooleanDAG))))

foreign import ccall safe "API.chs.h evt_prepare_miter"
  evt_prepare_miter'_ :: ((InterpreterEnvironment) -> ((BooleanDAG) -> ((BooleanDAG) -> (IO (BooleanDAG)))))

foreign import ccall safe "API.chs.h evt_assert_dag"
  evt_assert_dag'_ :: ((InterpreterEnvironment) -> ((BooleanDAG) -> (IO CInt)))

foreign import ccall safe "API.chs.h evt_is_ready"
  evt_is_ready'_ :: ((InterpreterEnvironment) -> (IO CInt))

foreign import ccall safe "API.chs.h evt_print_controls"
  evt_print_controls'_ :: ((InterpreterEnvironment) -> ((Ptr CChar) -> (IO ())))

foreign import ccall safe "API.chs.h node_vec_size"
  node_vec_size'_ :: ((NodeVector) -> (IO CInt))

foreign import ccall safe "API.chs.h node_vec_get"
  node_vec_get'_ :: ((NodeVector) -> (CInt -> (IO (BoolNode))))

foreign import ccall safe "API.chs.h bdag_get_nodes_by_type"
  bdag_get_nodes_by_type'_ :: ((BooleanDAG) -> (CInt -> (IO (NodeVector))))

foreign import ccall safe "API.chs.h bn_is_minimize"
  bn_is_minimize'_ :: ((BoolNode) -> (IO CInt))
