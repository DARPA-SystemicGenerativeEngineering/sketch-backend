-- GENERATED by C->Haskell Compiler, version 0.16.3 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!


{-# LINE 1 "API.chs" #-}{-# LANGUAGE Arrows,
             BangPatterns,
             ConstraintKinds,
             DeriveDataTypeable,
             EmptyDataDecls,
             FlexibleContexts,
             FlexibleInstances, ForeignFunctionInterface,
             FunctionalDependencies,
             GADTs,
             GeneralizedNewtypeDeriving,
             ImpredicativeTypes,
             MultiParamTypeClasses,
             NamedFieldPuns,
             NoMonomorphismRestriction,
             RankNTypes,
             ScopedTypeVariables,
             StandaloneDeriving,
             TemplateHaskell,
             TupleSections,
             TypeFamilies,
             TypeOperators,
             TypeSynonymInstances,
             ViewPatterns #-}

module CegisCApi.API (
    -- * Types
    BNType (..),
    -- * API
    -- ** Initialize the command line
    cmdline_args,
    cl_get_in_name,
    cl_set_in_name,
    cl_get_out_name,
    -- ** Start running the backend
    strip_sketches_lines,
    runDriver,
    getEnvt,
    -- ** Core synthesis commands
    evt_get_copy,
    evt_prepare_miter,
    evt_assert_dag,
    evt_is_ready,
    evt_print_controls,
    -- ** Manipulating the DAG
    bdag_get_nodes_by_type
    ) where

import Prelude hiding (id, (.))
import Control.Arrow
import Control.Applicative
import Control.Category
import Control.Monad
import Control.Monad.Trans.Class

import qualified Data.List.HT as HT

import Text.Regex.TDFA

import Text.Printf

import Foreign.Marshal.Array
import Foreign.Ptr
import Foreign.C.String
import Foreign.C.Types


{-# LINE 66 "API.chs" #-}
newtype BoolNode = BoolNode (Ptr (BoolNode))
{-# LINE 67 "API.chs" #-}
newtype NodeVector = NodeVector (Ptr (NodeVector))
{-# LINE 68 "API.chs" #-}
newtype BooleanDAG = BooleanDAG (Ptr (BooleanDAG))
{-# LINE 69 "API.chs" #-}
newtype CommandLineArgs = CommandLineArgs (Ptr (CommandLineArgs))
{-# LINE 70 "API.chs" #-}
newtype InterpreterEnvironment = InterpreterEnvironment (Ptr (InterpreterEnvironment))
{-# LINE 71 "API.chs" #-}
data BNType = BnAnd
            | BnOr
            | BnXor
            | BnSrc
            | BnDst
            | BnNot
            | BnCtrl
            | BnPlus
            | BnTimes
            | BnDiv
            | BnMod
            | BnNeg
            | BnConst
            | BnGt
            | BnGe
            | BnLt
            | BnLe
            | BnEq
            | BnAssert
            | BnArracc
            | BnUfun
            | BnArrass
            | BnActrl
            deriving (Enum,Show,Eq)

{-# LINE 72 "API.chs" #-}



{- Marshaling functions -}
fromEnum' = fromIntegral . fromEnum
toBool = (/= 0)

cStringArray :: [String] -> IO (Ptr CString)
cStringArray = newArray <=< mapM newCString




-- | You probably want to run this function first.
--   Pass it an array of arguments, like
--
-- > cmdline_args [ "--verbosity", "5", "infile", "outfile" ]
cmdline_args :: [String] -> IO CommandLineArgs
cmdline_args x = do
    res <- cmdline_args_ (length x) =<< cStringArray x
    res <$ cl_set_global_params res

-- helpers
cmdline_args_ :: Int -> (Ptr CString) -> IO (CommandLineArgs)
cmdline_args_ a1 a2 =
  let {a1' = fromIntegral a1} in 
  let {a2' = id a2} in 
  cmdline_args_'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 97 "API.chs" #-}
cl_set_global_params :: CommandLineArgs -> IO ()
cl_set_global_params a1 =
  let {a1' = id a1} in 
  cl_set_global_params'_ a1' >>= \res ->
  return ()
{-# LINE 99 "API.chs" #-}

-- | Get the input filename, as parsed by cegis command line handler.
cl_get_in_name :: CommandLineArgs -> IO (String)
cl_get_in_name a1 =
  let {a1' = id a1} in 
  cl_get_in_name'_ a1' >>= \res ->
  peekCAString res >>= \res' ->
  return (res')
{-# LINE 102 "API.chs" #-}

cl_set_in_name :: CommandLineArgs -> String -> IO ()
cl_set_in_name a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  cl_set_in_name'_ a1' a2' >>= \res ->
  return ()
{-# LINE 104 "API.chs" #-}

-- | Get the output filename, as parsed by cegis command line handler.
cl_get_out_name :: CommandLineArgs -> IO (String)
cl_get_out_name a1 =
  let {a1' = id a1} in 
  cl_get_out_name'_ a1' >>= \res ->
  peekCAString res >>= \res' ->
  return (res')
{-# LINE 107 "API.chs" #-}

-- | Set the verbosity; 5 is very verbose, -1 should print nearly nothing
cl_set_verbosity :: CommandLineArgs -> Int -> IO ()
cl_set_verbosity a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  cl_set_verbosity'_ a1' a2' >>= \res ->
  return ()
{-# LINE 110 "API.chs" #-}



-- | Call this after 'cmdline_args'. Reads a program from the input filename,
-- creates a DAG (circuit representation), and starts solving if there are
-- any \"assert ... SKETCHES ...;\" lines present.
runDriver :: IO ()
runDriver =
  runDriver'_ >>= \res ->
  return ()
{-# LINE 117 "API.chs" #-}

-- | Get the C-global environment generated by 'runDriver'
getEnvt :: IO (InterpreterEnvironment)
getEnvt =
  getEnvt'_ >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 120 "API.chs" #-}

-- | Get a copy of a function's DAG
evt_get_copy :: InterpreterEnvironment -> String -> IO (BooleanDAG)
evt_get_copy a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  evt_get_copy'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 123 "API.chs" #-}

-- | DAG representing the assertion \"forall in. spec(in) == sketch(in)\". Arguments:
--
-- > evt_prepare_miter spec sketch
evt_prepare_miter :: InterpreterEnvironment -> BooleanDAG -> BooleanDAG -> IO (BooleanDAG)
evt_prepare_miter a1 a2 a3 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  let {a3' = id a3} in 
  evt_prepare_miter'_ a1' a2' a3' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 130 "API.chs" #-}

-- | Solves a DAG, usually the output of 'evt_prepare_miter'
evt_assert_dag :: InterpreterEnvironment -> BooleanDAG -> IO (Int)
evt_assert_dag a1 a2 =
  let {a1' = id a1} in 
  let {a2' = id a2} in 
  evt_assert_dag'_ a1' a2' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 134 "API.chs" #-}

-- | Returns if the sketch has a valid solution (write it out with 'evt_print_controls')
evt_is_ready :: InterpreterEnvironment -> IO (Bool)
evt_is_ready a1 =
  let {a1' = id a1} in 
  evt_is_ready'_ a1' >>= \res ->
  let {res' = toBool res} in
  return (res')
{-# LINE 137 "API.chs" #-}

-- | Throws an error if the environment is not ready
evt_check_ready :: InterpreterEnvironment -> IO InterpreterEnvironment
evt_check_ready ie = go <$> evt_is_ready ie where
    go False = error "Could not resolve sketch."
    go True = ie

-- | Write the current solutions to a filename
evt_print_controls :: InterpreterEnvironment -> String -> IO ()
evt_print_controls a1 a2 =
  let {a1' = id a1} in 
  withCString a2 $ \a2' -> 
  evt_print_controls'_ a1' a2' >>= \res ->
  return ()
{-# LINE 147 "API.chs" #-}



-- marshalling vectors
unpackNodeVec :: NodeVector -> IO [BoolNode]
unpackNodeVec nv = do
    l <- node_vec_size nv
    forM [0..l - 1] (node_vec_get nv)
node_vec_size :: NodeVector -> IO (Int)
node_vec_size a1 =
  let {a1' = id a1} in 
  node_vec_size'_ a1' >>= \res ->
  let {res' = fromIntegral res} in
  return (res')
{-# LINE 156 "API.chs" #-}
node_vec_get :: NodeVector -> Int -> IO (BoolNode)
node_vec_get a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromIntegral a2} in 
  node_vec_get'_ a1' a2' >>= \res ->
  let {res' = id res} in
  return (res')
{-# LINE 157 "API.chs" #-}

-- | Get a list of all nodes of a particular type from the tree
bdag_get_nodes_by_type :: BooleanDAG -> BNType -> IO ([BoolNode])
bdag_get_nodes_by_type a1 a2 =
  let {a1' = id a1} in 
  let {a2' = fromEnum' a2} in 
  bdag_get_nodes_by_type'_ a1' a2' >>= \res ->
  unpackNodeVec res >>= \res' ->
  return (res')
{-# LINE 161 "API.chs" #-}

-- | Determine whether a control node (star) should be minimized
bn_is_minimize :: BoolNode -> IO (Bool)
bn_is_minimize a1 =
  let {a1' = id a1} in 
  bn_is_minimize'_ a1' >>= \res ->
  let {res' = toBool res} in
  return (res')
{-# LINE 164 "API.chs" #-}


-- | Pair containing a sketch and a specification
data SketchSpec = SketchSpec {
    sketch :: String,
    spec :: String }
    deriving (Eq, Show, Ord)

-- | Strip \"assert ... SKETCHES ...\" from the file.
-- Effectively prevents runDriver from doing anything
-- until you call 'evt_prepare_miter' later. Common usage:
--
-- @
--     in_nme <- cl_get_in_name cli
--     (in_nme', sketches) <- strip_sketches_lines in_nme
--     cl_set_in_name cli in_nme' -- use the new name
-- @
strip_sketches_lines fn@((++ ".fcns-only") -> fn') = do
    ls <- lines <$> readFile fn
    let re = "^assert ([a-zA-Z0-9_]+) SKETCHES ([a-zA-Z0-9_]+);$"
        (sketches, ls') = HT.partition (=~ re) ls
    writeFile fn' (unlines ls')
    return (fn', map (untuple . (=~ re)) sketches)
    where untuple [[_, sketch, spec]] = SketchSpec sketch spec
          untuple x = error ("untuple -- unexpected input " ++ show x)


data HsCegisArgs = HsCegisArgs {
    minimize :: Bool,
    num_solutions :: Integer }
defArgs = HsCegisArgs {
    minimize = False,
    num_solutions = 1 }

reparse_args :: [String] -> (HsCegisArgs, [String])
reparse_args l = check $ go l (defArgs, []) where
    go ("--num-solutions":x:xs) = go xs . first (\args -> args { num_solutions = read x })
    go ("--minimize":xs) = go xs . first (\args -> args { minimize = True })
    go (x:xs) = second (x:) . go xs
    go [] = id
    check x@(HsCegisArgs { minimize, num_solutions }, _)
        | minimize && num_solutions /= 1 = error "use either --minimize or --num-solutions"
        | otherwise = x

test_args = [ "--verbosity", "5",
    "--minimize",
    -- "--num-solutions", "2",
    "-o", "/home/gatoatigrado/.sketch/tmp/miniTest1.sk/solution",
    "/home/gatoatigrado/.sketch/tmp/miniTest1.sk/input.tmp" ]

minimize_sketch
  :: InterpreterEnvironment -> CommandLineArgs -> [(SketchSpec, BooleanDAG)] -> String -> IO ()
minimize_sketch e cli ss_miters fn = do
    putStrLn "\n\nstarting minimize routine"
    evt_check_ready e
    cl_set_verbosity cli (-1)
    cl_set_global_params cli

    let solve_all_dags = do
            forM ss_miters $ \(_, dag) -> evt_assert_dag e dag
            evt_is_ready e

    -- extract all minimize nodes from all dags
    min_nodes <- forM ss_miters $ \(ss, dag) -> do
        nodes <- filterM bn_is_minimize =<< bdag_get_nodes_by_type dag BnCtrl
        putStrLn $ printf "number of minimize control in dag nodes in sketch %s: %d"
            (sketch ss) (length nodes)
        return (ss, dag, nodes)

    -- minimize
    go min_nodes where
        go [] = return ()
        go ((ss, dag, []):xs) = go xs
        go ((ss, dag, (n:ns)):xs) = go' ss dag n >> go ((ss, dag, ns):xs)
        go' ss dag n = undefined
        {---------------------------------------------------
        -- withEvt
        -- forM nodes $ \n -> do
        --     if
        --     evt_print_controls evt fn
        -- return (ss, dag, nodes)
        ----------------------------------------------------}

    {---------------------------------------------------
    -- forM min_nodes
    --     lastSuccessfulValue = self.envt.currentControls[hole.get_name()]
    --     while(toIterate):
    --         self.writeSolutions(num=0)
    --         print 'lastSuccessfulValue = ', lastSuccessfulValue
    --         newDag = BooleanDAG()
    --         bgProblem = self.bDag.clone()
    --         ctrlNodes = bgProblem.getNodesByType(bool_node.CTRL)
    --         hole_clone = None
    --         for i in xrange(len(ctrlNodes)):
    --             if(ctrlNodes[i].get_name() == hole.get_name()):
    --                 hole_clone = ctrlNodes[i]
    --                 break
    --         newDag.addNewNode(hole_clone)
    --         constNode = newDag.new_node(None, None, bool_node.CONST)
    --         constNode.setVal(lastSuccessfulValue)
    --         ltNode = newDag.new_node(hole_clone, constNode, bool_node.LT)
    --         assertNode = newDag.new_node(ltNode, None, bool_node.ASSERT)
    --         self.envt.assertDAG_wrapper(newDag)
    --         if self.envt.status == InterpreterEnvironment.STATUS.READY:
    --             lastSuccessfulValue = self.envt.currentControls[hole.get_name()]
    --         elif self.envt.status == InterpreterEnvironment.STATUS.UNSAT:
    --             toIterate = False
    --         else:
    --             assert False, "Missing case for InterpreterEnvironment.STATUS enum"     
    --     constNode = self.bDag.new_node(None, None, bool_node.CONST)
    --     constNode.setVal(lastSuccessfulValue)
    --     eqNode = self.bDag.new_node(hole, constNode, bool_node.EQ)
    --     self.bDag.new_node(eqNode, None, bool_node.ASSERT)
    --     print('Minimum value of hole ' + str(hole.get_name()) + ' is ' + str(lastSuccessfulValue))
    ----------------------------------------------------}

    {---------------------------------------------------
    -- assert self.envt.status == InterpreterEnvironment.STATUS.READY, "Can't minimize the buggy sketch"
    -- self.cmdLineArgs.verbosity = -1
    -- self.cmdLineArgs.setPARAMS()
    -- ctrlNodes = self.bDag.getNodesByType(bool_node.CTRL)
    -- toMinimizeNodes = []
    -- for i in xrange(len(ctrlNodes)):
    --     if ctrlNodes[i].get_toMinimize():
    --         toMinimizeNodes.append(ctrlNodes[i])
    -- for i in xrange(len(toMinimizeNodes)):
    --     self.minimizeHole(toMinimizeNodes[i])
    ----------------------------------------------------}


test = do
    let (args, backend_args) = reparse_args test_args
    cli <- cmdline_args backend_args

    -- strip "assert ... sketches ..." from input,
    -- set input to that new file
    nme <- cl_get_in_name cli
    (nme', sketches) <- strip_sketches_lines nme
    cl_set_in_name cli nme'

    outname <- (\x (n :: Integer) -> printf "%s-%03d" x n) <$>
        cl_get_out_name cli

    -- build DAGs from the input functions
    runDriver
    e <- getEnvt

    -- resolve all of the DAGs, return pairs of miters and sketch-specs
    ss_miters <- forM sketches $ \ss@(SketchSpec { sketch, spec }) -> do
        sk_copy <- evt_get_copy e sketch
        spec_copy <- evt_get_copy e spec
        bd <- evt_prepare_miter e spec_copy sk_copy
        evt_assert_dag e bd
        return (ss, bd)

    -- write the first solution out
    evt_check_ready e
    evt_print_controls e (outname 0)

    if (minimize args) then
        minimize_sketch e cli ss_miters (outname 0)
    else return ()

    -- forM [2..num_solutions args] $ \j -> do
        -- ...

    -- print "num solutions"
    -- print (num_solutions args)

    print "done"

foreign import ccall safe "API.chs.h cmdline_args"
  cmdline_args_'_ :: (CInt -> ((Ptr (Ptr CChar)) -> (IO (CommandLineArgs))))

foreign import ccall safe "API.chs.h cl_set_global_params"
  cl_set_global_params'_ :: ((CommandLineArgs) -> (IO ()))

foreign import ccall safe "API.chs.h cl_get_in_name"
  cl_get_in_name'_ :: ((CommandLineArgs) -> (IO (Ptr CChar)))

foreign import ccall safe "API.chs.h cl_set_in_name"
  cl_set_in_name'_ :: ((CommandLineArgs) -> ((Ptr CChar) -> (IO ())))

foreign import ccall safe "API.chs.h cl_get_out_name"
  cl_get_out_name'_ :: ((CommandLineArgs) -> (IO (Ptr CChar)))

foreign import ccall safe "API.chs.h cl_set_verbosity"
  cl_set_verbosity'_ :: ((CommandLineArgs) -> (CInt -> (IO ())))

foreign import ccall safe "API.chs.h runDriver"
  runDriver'_ :: (IO ())

foreign import ccall safe "API.chs.h getEnvt"
  getEnvt'_ :: (IO (InterpreterEnvironment))

foreign import ccall safe "API.chs.h evt_get_copy"
  evt_get_copy'_ :: ((InterpreterEnvironment) -> ((Ptr CChar) -> (IO (BooleanDAG))))

foreign import ccall safe "API.chs.h evt_prepare_miter"
  evt_prepare_miter'_ :: ((InterpreterEnvironment) -> ((BooleanDAG) -> ((BooleanDAG) -> (IO (BooleanDAG)))))

foreign import ccall safe "API.chs.h evt_assert_dag"
  evt_assert_dag'_ :: ((InterpreterEnvironment) -> ((BooleanDAG) -> (IO CInt)))

foreign import ccall safe "API.chs.h evt_is_ready"
  evt_is_ready'_ :: ((InterpreterEnvironment) -> (IO CInt))

foreign import ccall safe "API.chs.h evt_print_controls"
  evt_print_controls'_ :: ((InterpreterEnvironment) -> ((Ptr CChar) -> (IO ())))

foreign import ccall safe "API.chs.h node_vec_size"
  node_vec_size'_ :: ((NodeVector) -> (IO CInt))

foreign import ccall safe "API.chs.h node_vec_get"
  node_vec_get'_ :: ((NodeVector) -> (CInt -> (IO (BoolNode))))

foreign import ccall safe "API.chs.h bdag_get_nodes_by_type"
  bdag_get_nodes_by_type'_ :: ((BooleanDAG) -> (CInt -> (IO (NodeVector))))

foreign import ccall safe "API.chs.h bn_is_minimize"
  bn_is_minimize'_ :: ((BoolNode) -> (IO CInt))
