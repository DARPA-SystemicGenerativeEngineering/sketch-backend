For meeting:
    1. Sketch frontend is optimizing out any functions not used by a harness.
    2. What is the replace map?


Crucial
1. Write thesis
    1.1. outline
    1.2. rest

Necessary
1. Complete language
    DONE 1.-1. Remove ; at the end of {} blocks
    DONE 1.0. Add {} block
    1.01. complete if - else block.
    1.02. complete if - else if ... - else block
    DONE 1.1. implement subscoping for {} nesting (for, while, if, {}}
    1.2. complete boolean predicates
        DONE: >, <, >=, ==
        TODO: <=, &&, ||, !
    1.3. implement integer and float expressions
        DONE: +, -, /, *
        TODO: %
    DONE 1.4. Implement garbage collection
    1.5. Remove harness from argument in File.
    1.6. Remove need for ..__Wrapper
    1.7. There should be a version of solvers that returns a concretized function rather than a solution.
    1.8. add [] for accessing arrays;
    1.9. add (,) as a pair constructor.
    1.^1 implement lambdas.
    DONE 1.^2 Refactor FunctionCall
    1.^.3 get rid of outname in UFUN_node
2. Incorporate numerical solver
3. Incorporate doallpairs
3. Fix memory leaks (remove all boolean dag copies that are not used).
    DONE in SolverLanguage
        DONE use SCHECKMEM in boolean_node and boolean_dag
        DONE CUSTOM use shared_pointer
    TODO In rest of codebase
4. Dynamic typing
    DONE.
    DONE add 'any' type.
6. Implement methods for modification of sketches
    6.1. CloneAndRename
    6.2. Replace this with this in this
        6.2.1 recursive replace (when replaced, and then replacing again, replace in the previously replaced dag as well).
5. Make frontend spit harnesses for each function when using solver language.
    5.1. be careful of structs as inputs.
6. remove debug code
    6.1. turn off SCHECKMEM
    6.2. add flag for checking file consistentcy in cegis solver and checker.
7. Set up pipeline
    7.1. Thread params for which file to use
    7.2. Two pipelines: old and new
    7.3. merge with master.

Good to do
Refactor interpreter to use classes and subclasses instead of switches for different values/methods (like in SolverLanguage.h).

Medium term
0. Implement useful error/warning messages with line numbers.
1. refactor backend code to look like solver language (meaning the signatures of the functions concretize and file).
    1.1 Compile directly to Cpp rather than interpreting program
2. Implement bottom-up-and-top-down STUN for boolean synthesis in solver language
3. Implement classes
4. Allow for construction of sketches during runtime.

Other medium terms
1. Holes in solver program and meta-solver programs

Longer term
1. Implement other domains using solver language
    1.1. Karel
    1.2 compression
        1.2.1 Geometric images
        1.2.2 Timeseries
2. How to integrate with hardcoder and parallelism
    1. Have doallparis be a module.
    2. ...