For meeting:
    1. Sketch frontend is optimizing out any functions not used by a harness.
    2. What is the replace map?
    3. Raise issue about
            bit one = 1;
            assert(program(num_bools, bools) == one);
        vs
            assert(program(num_bools, bools) == 1);

     4. ASK ABOUT
           void NodeEvaluator::visit( TUPLE_CREATE_node &node){

           	int sz = node.nparents();
           	cptuple* cpv = new cptuple(sz);
           	if(tuplevalues[node.id] != NULL){
           		delete tuplevalues[node.id];
           	}
           	tuplevalues[node.id] = cpv;
               Tuple* otp = (Tuple*)node.getOtype();
           	for(int t=0; t<sz; ++t){
                   OutType* e = otp->entries[t];
                   if(e==OutType::INT || e==OutType::BOOL || e->isTuple) {
                     cpv->vv[t] = i(*node.get_parent(t));
                   } else {
                     cpv->vv[t] = (node.get_parent(t)->id);
                   }
           	}
           	setbn(node, node.id );// <<<<<<<<<<<<<< HERE WHY node.id rather than values[node.id]?

           }


TODO: Priority for merging with Master
    1. Add separate file as console output for Solver Language.
    2. remove debug code
        *6.1. turn off SCHECKMEM
        *6.2. add flag for checking file invariant in cegis solver and checker.
        *6.3. add flag for checking translation invariant between VarStore and InputHolder/SolutionHolder in Assignment_SkVal
    3. Set up pipeline
        *7.1. Thread params for which file to use
        *7.2. Two pipelines: old and new
        *7.3. merge with master.

TODO: Priority for integration with Siemens
    1. Integrate with Python frontend.

Use-cases
Implement bottom-up-and-top-down STUN for boolean synthesis in solver language
    DONE: one shot level1. (bot-top-bot)
    DONE: bot-top-bot-top
    TODO: implement 'synthesize_composite_programs_from_parts' as a constructed sketch. (instead of the two for loops, make them holes in a sketch)
    TODO: iterative lvl1.
    TODO: one shot lvl2
    TODO: iterative lvl2
    TODO: crete more complicated zig-zag example.

Necessary
1. Complete language
    DONE 1.-1. Remove ; at the end of {} blocks
    DONE 1.0. Add {} block
    *TODO: 1.01. complete if - else block.
    *TODO: 1.02. complete if - else if ... - else block
    DONE 1.1. implement subscoping for {} nesting (for, while, if, {}}
    1.2. complete boolean predicates
        DONE: >, <, >=, ==
        *TODO: <=, &&, ||, !
        *TODO: FIX ORDER OF OPERATIONS
    1.3. implement integer and float expressions
        DONE: +, -, /, *
        TODO: %
        *TODO: FIX ORDER OF OPERATIONS
    DONE 1.4. Implement garbage collection
    TODO: 1.5. Remove harness from argument in File.
        1.5.1. Have current File be implemented as a vector rather than having a specific File class.
            Interpret an input as a InputStore right before using in a sketch.
    TODO: 1.6. Remove need for ..__Wrapper
    ~ 1.7. There should be a version of solvers that returns a concretized function rather than a solution.
    TODO: 1.8. add [] for accessing arrays;
    *TODO: 1.9. add (,) as a pair constructor.
    DONE 1.^1 implement lambdas.
    DONE 1.^2 Refactor FunctionCall
    TODO: 1.^3 get rid of outname in UFUN_node
    DONE 1.^4 implement <file>.produce_filter
    *TODO: 1.^5 refactor as needed and assert(false)s from explicit Assignment_SkVal(Assignment_SkVal* to_copy): Mapping<SkVal>()
    TODO: 1.^6 loop control flow operators
            continue
            break
    *TODO: 1.^7 Add custom output files to Solver Language.
    TODO: Shed dead code.

TODO: 2. Incorporate numerical solver
TODO: 3. Incorporate doallpairs
3. Fix memory leaks (remove all boolean dag copies that are not used).
    DONE in SolverLanguage
        DONE use SCHECKMEM in boolean_node and boolean_dag
        DONE CUSTOM use shared_pointer
    TODO: In rest of codebase
DONE 4. Dynamic typing
    DONE add 'any' type.
6. Implement methods for modification of sketches
    6.1. DONE replace_produce, and replace
    *TODO: 6.2. Fix renaming.
    TODO: 6.3. Add functionality to frontend.
    DONE: 6.4  Allow concretized sketches to be executed on inputs, and their result read.
        TODO: 6.4.1: fix the weirdness where the output of a function is a tuple, so you need to go to it's first parent to get the true value in node_evaluator.
TODO: 5. Make frontend spit harnesses for each function when using solver language. Be careful of structs as inputs.

For Master's thesis
1. Write thesis
    1.1. outline
    1.2. rest

Good to do
Refactor interpreter to use classes and subclasses instead of switches for different values/methods (like in SolverLanguage.h).

Medium term
0. Implement useful error/warning messages with line numbers.
1. refactor backend code to look like solver language (meaning the signatures of the functions concretize and file).
    1.1 Compile directly to Cpp rather than interpreting program
3. Implement classes
4. Allow for construction of sketches during runtime.

Other medium terms
1. Holes in solver program and meta-solver programs

Longer term
1. Implement other domains using solver language
    1.1. Karel
    1.2 compression
        1.2.1 Geometric images
        1.2.2 Timeseries
2. How to integrate with hardcoder and parallelism
    1. Have doallparis be a module.
    2. ...