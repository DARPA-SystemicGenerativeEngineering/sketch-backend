Solver concatenate(arr1, arr2)
{
    n = arr2.size();
    for(i = 0;i<n;i++)
    {
        arr1.append(arr2.get(i));
    }
}

/*
generator int program_generator(int x) {
    //USER DEFINED
};

generator bit predicate_generator(int x)
{
    //USER DEFINED
}

bit predicate(int x)
{
    return predicate_generator(x);
}

bit condition(int x) {return 0;}

int if_true_branch(int x) {return 0;}

int if_false_branch(int x) {return 0;}

int composite_predicate(int x) {
    if(condition(x)) {
        return if_true_branch(x);
    }
    else {
        return if_false_branch(x);
    }
}

bit program_lvl0(int x) {
    return line(x);
}

int dummy_program(int x) {return 1;}

@FromFile("zig_zag.data")
harness void sketch_main(int x, bit out)
{
    assert(dummy_program(x) == out);
}

@FromFile("zig_zag.data")
harness void eval_predicate_main(int x, bit out)
{
    bit one = 1;
    assert(dummy_program(x) == one);
}

@FromFile("zig_zag.data")
harness void dummy_sketch_main(int x, bit out)
{
    assert(program(x) == 0);
    assert(program_lvl0(x) == out);
    assert(composite_predicate(x) == out);
}
*/

Solver best_effort_programs(harness, file, num_trials, num_rows_per_sample)
{
    solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);
    programs = [];
    for(int i = 0;i<solutions.size();i++)
    {
        programs.append(pair<int, SketchFunction>(solutions.get(i).first(), harness.produce_concretization(solutions.get(i).second())));
    }
    return programs;
}

Solver best_effort_synthesized_program(harness, file, num_trials, num_rows_per_sample)
{
    return harness.produce_concretization(
        best_effort_synthesis(harness, file, num_trials, num_rows_per_sample));
}

Solver main()
{
    return recursive_function_stun();
    //return stun_main();
    //return top_down_and_bottom_up_synthesis_sketch_main();
    //return left_and_right_and_cond_synthesis_sketch_main();
}

Solver synthesize_composite_programs_from_parts(left_programs, right_programs, select_best, file_name, num_trials, num_rows_per_sample)
{
    seed_main_lvl1 = [];

    assert(left_programs.size() >= select_best, "FAILED: left_programs.size() <= select_best");
    assert(right_programs.size() >= select_best, "FAILED: right_programs.size() <= select_best");

    for(int i = 0;i<select_best;i++) {
        for(int j = 0;j<select_best;j++) {
            print("LEFT", i+1, "/", select_best, "RIGHT", j+1, "/", select_best);
            predicate_lvl1 =
                composite_predicate.produce_replace("condition", predicate.clone());
            predicate_lvl1.replace("if_true_branch",
                program_lvl0.produce_concretization(left_programs.get(i).second().get_solution()));
            predicate_lvl1.replace("if_false_branch",
                program_lvl0.produce_concretization(right_programs.get(j).second().get_solution()));

            sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", predicate_lvl1);
            sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl1_sub);

            File file = File(file_name, sketch_main_lvl1);
            local_sketch_main_lvl1_programs = best_effort_programs(sketch_main_lvl1, file, num_trials, num_rows_per_sample);

            tmp = [];

            for(int k = 0; k < local_sketch_main_lvl1_programs.size();k++)
            {
                tmp.append(
                    pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                        local_sketch_main_lvl1_programs.get(k),
                        pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                            left_programs.get(i),
                            right_programs.get(j))));
            }

            local_sketch_main_lvl1_programs = tmp;

            concatenate(seed_main_lvl1, local_sketch_main_lvl1_programs);
        }
    }

    seed_main_lvl1.sort();
    seed_main_lvl1.reverse();

    assert(seed_main_lvl1.size() == ((select_best*select_best)*num_trials), "FAILED: seed_main_lvl1.size() == (select_best*select_best)");

    return seed_main_lvl1;
}

Solver check_predicate_and_assertion_consistency(the_predicate, file_name, the_harness)
{
    File file_for_predicate = File(file_name, the_predicate);
    File file_for_harness = File(file_name, the_harness);
    for(int i = 0;i<file_for_predicate.size();i++) {
        //print("out", i, "(predicate)", the_predicate(file_for_predicate.get(i)), "(harness)", the_harness.passes(file_for_harness.get(i)));
        assert(the_predicate(file_for_predicate.get(i)) == the_harness.passes(file_for_harness.get(i)), "MISSMATCH AT: ", i);
    }
}

Solver top_down_and_bottom_up_synthesis_sketch_main()
{
    //for now these are passed as parameters from the sketch.
    //the sketch follows a constraint that the file_names should be the same
    //string file_name = "uav_kg_big__as_bools.data";
    //string file_name = "zig_zag.data";

    int mult = 1;


    num_trials = 4*mult;
    num_rows_per_sample = 2;
    select_best = 1;
    assert(num_trials >= select_best);

    sketch_main_lvl0_sub = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
    sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl0_sub);

    File file = File(file_name, sketch_main_lvl0);
    left_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, num_trials, num_rows_per_sample);
    print("DONE left_lvl0_programs");
    right_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, num_trials, num_rows_per_sample);
    print("DONE right_lvl0_programs");

    assert(left_lvl0_programs.size() >= select_best);
    assert(right_lvl0_programs.size() >= select_best);

    num_trials = 1*mult;
    seed_main_lvl1 = synthesize_composite_programs_from_parts(left_lvl0_programs, right_lvl0_programs, select_best, file_name, num_trials, num_rows_per_sample);

    all_programs = [];
    concatenate(all_programs, seed_main_lvl1);

    improved_main_lvl1 = [];

    int prev_best = 0-1;
    int new_best = seed_main_lvl1.get(0).first().first();


    num_trials = 1*mult;
    //num_rows_per_sample = 6;
    //select_best = 2;
    assert(num_trials >= select_best);

    int iter_id = 0;

    while(new_best > prev_best)
    {
        print("NEW_ITERATION", iter_id);
        print("prev_best", prev_best, "new_best", new_best);

        prev_best = new_best;
        new_best = 0;

        for(int i = 0; i<seed_main_lvl1.size();i++)
        {
            improved_main_lvl1.append(seed_main_lvl1.get(i));
        }

        if(seed_main_lvl1.size() < select_best)
        {
            select_best = seed_main_lvl1.size();
        }

        outer_loop_select_best = select_best*2;

        if(outer_loop_select_best > seed_main_lvl1.size())
        {
            outer_loop_select_best = seed_main_lvl1.size();
        }

        assert(seed_main_lvl1.size() >= outer_loop_select_best, "FAILED: seed_main_lvl1.size() >= select_best");


        for(int i = 0;i<outer_loop_select_best;i++)
        {
            print("start i =", i+1, "/", outer_loop_select_best);
            print("prev_score: ", seed_main_lvl1.get(i).first().first());
            local_program = seed_main_lvl1.get(i).first().second();
            //take condition
            //condition_lvl1_sub_sub = predicate.produce_concretization(local_program.get_solution());
            condition_lvl1_sub_sub = predicate.produce_concretization(local_program.get_solution("condition"));
            condition_lvl1_sub = eval_predicate_main.produce_replace("dummy_predicate", condition_lvl1_sub_sub);
            condition_lvl1_sub_harness = eval_predicate_main_harness.produce_replace("eval_predicate_main", condition_lvl1_sub);
            condition_lvl1 = eval_predicate_main_harness__Wrapper.produce_replace("eval_predicate_main_harness", condition_lvl1_sub_harness);
    
            //run this to check consistency condition_lvl1 and condition_lvl1_sub
            //this makes sure that the function_call operation of sketches works as expected.
            check_predicate_and_assertion_consistency(condition_lvl1_sub, file_name, condition_lvl1);
    
            File file = File(file_name, condition_lvl1_sub);
            //split file based on condition
            if_true_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return condition_lvl1_sub(x);});
            if_false_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return not(condition_lvl1_sub(x));});
    
            print("if_true_file.size()", if_true_file.size());
            print("if_false_file.size()", if_false_file.size());

            bool entered = false;
            if(if_true_file.size() >= num_rows_per_sample) {
                if(if_false_file.size() >= num_rows_per_sample) {
                    entered = true;
                    print("ENTER i", i);
                    assert(if_true_file.size() >= num_rows_per_sample, "FAILED: if_true_file.size() >= num_rows_per_sample");
                    assert(if_false_file.size() >= num_rows_per_sample, "FAILED: if_false_file.size() >= num_rows_per_sample");
                    assert((if_true_file.size()+if_false_file.size()) == file.size(), "FAILED: if_true_file.size()+if_false_file.size() == file.size()");
    
                    //resynthesize lvl0 left and right predicates.
    
                    left_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
                    left_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", left_tmp);
                    if_true_file.relabel(left_sketch_main_lvl0);
                    left_sketch_main_lvl0_programs =
                        best_effort_programs(left_sketch_main_lvl0, if_true_file, num_trials*select_best*select_best, num_rows_per_sample);
                    print("DONE (i = ", i, ") left_sketch_main_lvl0_programs");
                    left_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().first());
                    left_sketch_main_lvl0_programs.sort();
                    left_sketch_main_lvl0_programs.reverse();
    
                    right_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
                    right_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", right_tmp);
                    if_false_file.relabel(right_sketch_main_lvl0);
                    right_sketch_main_lvl0_programs = best_effort_programs(right_sketch_main_lvl0, if_false_file, num_trials*select_best*select_best, num_rows_per_sample);
                    print("DONE (i = ", i, ") right_sketch_main_lvl0_programs");
                    right_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().second());
                    right_sketch_main_lvl0_programs.sort();
                    right_sketch_main_lvl0_programs.reverse();
    
                    //combine with condition
    
                    new_best_predicate_lvl1 = composite_predicate.produce_replace("condition", condition_lvl1_sub_sub);
                    new_best_predicate_lvl1.replace("if_true_branch",
                        program_lvl0.produce_concretization(left_sketch_main_lvl0_programs.get(0).second().get_solution()));
                    new_best_predicate_lvl1.replace("if_false_branch",
                        program_lvl0.produce_concretization(right_sketch_main_lvl0_programs.get(0).second().get_solution()));
    
                    new_best_sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", new_best_predicate_lvl1);
                    new_best_sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", new_best_sketch_main_lvl1_sub);
    
                    file = File(file_name, new_best_sketch_main_lvl1);
                    int score = count_passing_inputs(new_best_sketch_main_lvl1, file);
    
                    print("new_score:", score);


                    improved_main_lvl1.append(
                        pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                            pair<int, SketchFunction>(score, new_best_sketch_main_lvl1),
                            pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                                left_sketch_main_lvl0_programs.get(0),
                                right_sketch_main_lvl0_programs.get(0))));


                    //commented out in ordeer to test the existence of solutions in the very previous statement.

                    new_synthesized_lvl1 =
                        synthesize_composite_programs_from_parts(
                            left_sketch_main_lvl0_programs, right_sketch_main_lvl0_programs,
                            select_best, file_name, num_trials, num_rows_per_sample);
    
                    print("synthesized_best_score: ", new_synthesized_lvl1.get(0).first().first());
    
                    concatenate(improved_main_lvl1, new_synthesized_lvl1);
                }
            }
            if(not(entered))
            {
                if(outer_loop_select_best < seed_main_lvl1.size())
                {
                    outer_loop_select_best = outer_loop_select_best+1;
                }
            }
            print("done i =", i);
        }

        improved_main_lvl1.sort();
        improved_main_lvl1.reverse();

        print("SORTED");

        new_best = improved_main_lvl1.get(0).first().first();
        print("new_best:", new_best);
        seed_main_lvl1 = improved_main_lvl1;
        improved_main_lvl1 = [];
        concatenate(all_programs, seed_main_lvl1);

        all_programs.sort();
        all_programs.reverse();

        for(int i = 0; i<all_programs.size(); i++)
        {
            element = all_programs.get(i);
            score = element.first().first();
            n = file.size();
            print("count ", score, "/", n, "= (", ((float(100) * float(score)) / float(n)), "%)");
        }
        print("Done sorted all_programs scores");
        print("best_from_all_programs = ", best_score);

        print("UPDATED seed_main_lvl1");

        //num_trials = num_trials+4;
        //num_rows_per_sample++;
        //select_best = select_best+1;
        assert(num_trials >= select_best);
    }


    assert(new_best == prev_best);

    all_programs.sort();
    all_programs.reverse();

    assert(seed_main_lvl1.size() >= 1);
    assert(all_programs.size() >= 1);
    assert(all_programs.size() >= seed_main_lvl1.size());
    assert(all_programs.get(0).first().first() == seed_main_lvl1.get(0).first().first());

	for(int i = 0; i<all_programs.size(); i++)
	{
	    element = all_programs.get(i);
	    score = element.first().first();
	    n = file.size();
	    print("count ", score, "/", n, "= (", ((float(100) * float(score)) / float(n)), "%)");
	}
	print("Done sorted all_programs scores");
	print("best_from_all_programs = ", best_score);

    return all_programs.get(0).first().second();
}

/*

bit composite_predicate(x)
{
    if(condition(x))
    {
        return composite_predicate(x);
    }
    else
    {
        return program_lvl0();
    }
}

*/

Solver recursive_program_constructor(int stun_depth, file, num_trials, num_rows_per_sample)
{

    harness_levels = [];

    for(int i = 0;i<stun_depth;i++)
    {
        if(i == 0)
        {
            mhw_lvl0 = best_effort_synthesized_program(sketch_main__Wrapper, file, num_trials, num_rows_per_sample);

            if(false)
            {
                to_eval = eval_program_main_harness.produce_replace("dummy_program", mhw_lvl0.get("sketch_main").get("composite_predicate"));

                local_file = File(file_name, to_eval);
                for(int k = 0;k < local_file.size(); k++)
                {
                    if(to_eval.passes(local_file[k])){
                        //print("composite_predicate(file[", k, "]) passes");
                        print("composite_predicate(file[", k, "]) = ", to_eval(local_file[k]));
                    }
                    else
                    {
                        print("composite_predicate(file[", k, "]) fails");
                    }
                }
            }

            harness_levels.append(mhw_lvl0);
        }
        else
        {

            assert(i >= 1);

            cp_lvl_i = composite_predicate.clone();

            cp_lvl_i.replace("composite_predicate", harness_levels[i-1].get("sketch_main").get("composite_predicate"));

            sketch_main.replace("composite_predicate", cp_lvl_i);

            mhw_lvl_i = best_effort_synthesized_program(sketch_main__Wrapper, file, num_trials, num_rows_per_sample);

            harness_levels.append(mhw_lvl_i);
        }

        score = count_passing_inputs(harness_levels[i], file);

        print("score[", i, "] =", score);
    }

    return harness_levels[stun_depth-1];
}

Solver recursive_function_stun()
{
    File file = File(file_name, sketch_main__Wrapper);

    num_trials = 2;
    num_rows_per_sample = 3;

    int stun_depth = 3;

    recursive_program = recursive_program_constructor(stun_depth, file, num_trials, num_rows_per_sample);

    check_harness_levels = [];

    for(int i = 0;i<stun_depth;i++)
    {
        cp_lvl_i = composite_predicate.clone();

        for(int j = 0; j<i;j++)
        {
            cp_lvl_i = cp_lvl_i.produce_replace("composite_predicate", cp_lvl_i);
        }

        at_level = recursive_program.get("sketch_main").get("composite_predicate");

        for(int j = 0; j<(stun_depth-i);j++) {
            at_level = at_level.get("composite_predicate");
        }

        cp_lvl_i.concretize(at_level.get_solution());

        sketch_main.replace("composite_predicate", at_level);
        score_ground_truth = count_passing_inputs(sketch_main__Wrapper, file);
        sketch_main.replace("composite_predicate", cp_lvl_i);
        score_predicted = count_passing_inputs(sketch_main__Wrapper, file);

        print("score_ground_truth == score_predicted:: ", score_ground_truth, " == ", score_predicted);
        assert(score_ground_truth == score_predicted, "FAILED: score_ground_truth == score_predicted:: ", score_ground_truth, " == ", score_predicted);

        check_harness_levels.append(sketch_main__Wrapper.produce_concretization());
    }

    sketch_main.reset("composite_predicate");

    return check_harness_levels[stun_depth-1];
    return check_harness_levels[stun_depth-1].get_solution();
}

Solver left_and_right_and_cond_synthesis_sketch_main()
{
    //first sample base level
    //choose best
    //sample left and right
    //choose best

    num_trials = 10;
    num_rows_per_sample = 6;
    select_best = 5;

    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";
    
    file = File(file_name, sketch_main_lvl0_left__Wrapper);
    lvl0_left_solutions = best_effort_solutions(sketch_main_lvl0_left__Wrapper, file, num_trials, num_rows_per_sample);

    file = File(file_name, sketch_main_lvl0_right__Wrapper);
    lvl0_right_solutions = best_effort_solutions(sketch_main_lvl0_right__Wrapper, file, num_trials, num_rows_per_sample);

    print("first lvl0_left_solutions.size() ", lvl0_left_solutions.size());
    print("first lvl0_right_solutions.size() ", lvl0_right_solutions.size());

    predicate_lvl0_left_original = predicate_lvl0_left.clone();
    predicate_lvl0_right_original = predicate_lvl0_right.clone();

    any ret;

    {
        all_compound_solutions = [];

        print("lvl0_left_solutions.size() ", lvl0_left_solutions.size());
        print("lvl0_right_solutions.size() ", lvl0_right_solutions.size());
        for(i = 0;i<select_best;i++)
        {
            predicate_lvl0_left.concretize(lvl0_left_solutions.get(i).second());
            for(j = 0;j<select_best; j++)
            {
                predicate_lvl0_right.concretize(lvl0_right_solutions.get(j).second());

                any compound_solutions;
                {
                    file = File(file_name, sketch_main_lvl1__Wrapper);
                    compound_solutions = best_effort_solutions(sketch_main_lvl1__Wrapper, file, num_trials, num_rows_per_sample);
                    //file.clear();
                }

                //this is not intuitive
                n_compound_solutions = compound_solutions.size();
                for(k = 0;k<n_compound_solutions; k++)
                {
                    compound_solutions.get(k).second().join(lvl0_left_solutions.get(i).second());
                    compound_solutions.get(k).second().join(lvl0_right_solutions.get(j).second());
                }

                concatenate(all_compound_solutions, compound_solutions);

                //predicate_lvl0_right.clear();
                predicate_lvl0_right = predicate_lvl0_right_original.clone();
            }

            //predicate_lvl0_left.clear();
            predicate_lvl0_left = predicate_lvl0_left_original.clone();
        }

        all_compound_solutions.sort();
        all_compound_solutions.reverse();

        ret = all_compound_solutions.get(0).second();
    }

    //predicate_lvl0_left.clear();
    predicate_lvl0_left = predicate_lvl0_left_original;
    //predicate_lvl0_right.clear();
    predicate_lvl0_right = predicate_lvl0_right_original;

    return ret;
}

Solver int get_score(SketchFunction harness, Solution solution, File file)
{
    SketchFunction program = harness.produce_concretization(solution); // create a program that uses the solution to fill in the holes of the harness.
    int score2 = count_passing_inputs(program, file); // count how many input-output examples are solved with this solution
    program.clear();
    return score2;
}

/*

Solver Solution original_sketch_main()
{
    return beam_search_sketch_main();
    //return repeat_greedy_sketch_main();
    //return stun_main();
}

Solver Solution beam_search_sketch_main()
{
    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";
    //string file_name = "uav_kg_big__as_bools__smaller.data";

    File file = File(file_name, sketch_main_lvl0__Wrapper); //unnatural, remove harness
    int total_num_rows = file.size();

    int num_trials = 10;
    int num_rows_per_sample = 6;
    int beam_breath = 3;

    vector<pair<int, Solution> > best_effort_solutions =
        best_effort_solutions(sketch_main_lvl0__Wrapper, file, num_trials, num_rows_per_sample);

    vector<pair<int, pair<int, Solution> > > indexed_solutions = vector<pair<int, pair<int, Solution> > >();
    //use python syntax for arrays

    int best_effort_solutions_size = best_effort_solutions.size();
    pair<int, Solution> element;
    for(int i = 0; i<best_effort_solutions_size; i++)
    {
        element = best_effort_solutions.get(i);
        indexed_solutions.append(
            pair<int, pair<int, Solution> >(
                element.first(), pair<int, Solution>(0, element.second())));
    }

    indexed_solutions.sort();
    indexed_solutions.reverse();

    int num_candidates = indexed_solutions.size();
    SketchFunction harness;
    vector<pair<int, pair<int, Solution> > > next_frontier = vector<pair<int, pair<int, Solution> > >();
    int local_n;
    int j;
    Solution tmp_solution;
    Solution partial_solution;
    SketchFunction throw_away;
    for(i = 0;i<beam_breath;i++)
    {
        harness = sketch_main_lvl1__Wrapper.clone();
        assert(indexed_solutions.get(i).second().first() == 0);
        partial_solution = indexed_solutions.get(i).second().second();
        harness.concretize(partial_solution);
        file = File(file_name, harness);
        best_effort_solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            next_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(1, tmp_solution)));
        }
        harness.clear();
    }


    next_frontier.sort();
    next_frontier.reverse();


    num_candidates = next_frontier.size();
    vector<pair<int, pair<int, Solution> > > final_frontier = vector<pair<int, pair<int, Solution> > >();
    int counter = 0;
    for(i = 0;i<beam_breath;i++)
    {
        harness = sketch_main_lvl2__Wrapper.clone();
        assert(next_frontier.get(i).second().first() == 1);
        partial_solution = next_frontier.get(i).second().second();
        harness.concretize(partial_solution);
        file = File(file_name, harness);
        best_effort_solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            final_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(2, tmp_solution)));
            counter++;
            print("score ", best_effort_solutions.get(j).first(), " counter ", counter);
        }
        harness.clear();
    }

    final_frontier.sort();
    final_frontier.reverse();

    assert(final_frontier.size() > 0);

    Solution ret_solution = final_frontier.get(0).second().second();

    return ret_solution;
}

Solver Solution repeat_greedy_sketch_main()
{
    string file_name = "zig_zag.data";
    File file = File(file_name, sketch_main_lvl2__Wrapper);
    int n = file.size();


    Solution sol = stun_main();
    int score = get_score(sketch_main_lvl2__Wrapper, sol, file);
    print("at_score ", score, "/", n);
    while(score < n)
    {
        seed++;
        sol = stun_main();
        score = get_score(sketch_main_lvl2__Wrapper, sol, file);
        print("at_score ", score, "/", n);
    }

    return sol;
}

*/

Solver stun_main()
{
	int num_trials = 20; //hyperparameter
	int num_rows = 6; //hyperparameter

    Solution total_solution = Solution();

    SketchFunction org_program_lvl0 = program_lvl0.clone();
    SketchFunction org_program_lvl1 = program_lvl1.clone();
    SketchFunction org_program_lvl2 = program_lvl2.clone();

    SketchFunction tmp_program_lvl0 = program_lvl0;
    SketchFunction tmp_program_lvl1 = program_lvl1;
    SketchFunction tmp_program_lvl2 = program_lvl2;

    program_lvl0 = org_program_lvl0;
    program_lvl1 = org_program_lvl1;
    program_lvl2 = org_program_lvl2;

	//solve the harness lvl0
	File file = File(file_name, main_lvl0__Wrapper); // The dataset is stored in a File; File is a native construct.
	print("main_lvl0__Wrapper.num_holes() = ", main_lvl0__Wrapper.num_holes());
	Solution solution_lvl0 = best_effort_synthesis(main_lvl0__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl0);

	//concretize the predicate lvl0
	program_lvl0.concretize(solution_lvl0);

	//solve the harness lvl1
	file = File(file_name, main_lvl1__Wrapper);
	print("main_lvl1__Wrapper.num_holes() = ", main_lvl1__Wrapper.num_holes());
	Solution solution_lvl1 = best_effort_synthesis(main_lvl1__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl1);

	//concretize the predicate lvl1
	program_lvl1.concretize(solution_lvl1);

	//solve the harness lvl2
	file = File(file_name, main_lvl2__Wrapper);
	print("main_lvl2__Wrapper.num_holes() = ", main_lvl2__Wrapper.num_holes());
	Solution solution_lvl2 = best_effort_synthesis(main_lvl2__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl2);

	//concretize the predicate lvl2
	program_lvl2.concretize(solution_lvl2);

	//done, no more predicates to concretize.


    program_lvl0 = tmp_program_lvl0;
    program_lvl1 = tmp_program_lvl1;
    program_lvl2 = tmp_program_lvl2;

	return total_solution;
}

Solver best_effort_solutions(SketchFunction harness, File file, int num_trials, int num_rows) {
	Solution best_solution;
	int best_score = 0;

    File subset_file;
    Solution solution;
    SketchFunction program;
    int score;

    vector<pair<int, Solution> > solutions = vector<pair<int, Solution> >();
    for(int trial_id = 0; trial_id<num_trials; trial_id++)
	{
		subset_file = file.produce_subset_file(num_rows); //sample subset of the rows
		solution = SATSolver(harness, subset_file); // invoke the Sketch Solver on the harness
		subset_file.clear();
		score = get_score(harness, solution, file);
		print("TRIAL", trial_id+1, "/", num_trials, "SCORE", score);
		solutions.append(pair<int, Solution>(score, solution));
		if(score > best_score) // update the best_solution
		{
			best_solution = solution;
			best_score = score;
		}
	}

	solutions.sort();
	solutions.reverse();

	print("Sorted solution scores:");

	int solutions_size = solutions.size();

    pair<int, Solution> element;
	for(int i = 0; i<solutions_size; i++)
	{
	    element = solutions.get(i);
	    print("count ", element.first(), "/", file.size(), "= (", ((float(100) * float(element.first())) / float(file.size())), "%)");
	}
	print("Done sorted solution scores");

	print("best_score = ", best_score);

    assert(solutions.size() == num_trials);

    print("ASSERTED TRUE:", "solutions.size()", solutions.size(), "num_trials", num_trials);

    return solutions;
}

Solver best_effort_synthesis(SketchFunction harness, File file, int num_trials, int num_rows) {
    vector<pair<int, Solution> > solutions = best_effort_solutions(harness, file, num_trials, num_rows);
    int solutions_size = solutions.size();
    Solution ret = solutions.get(0).second();
	return ret;
}

//subroutine to count the number of passing input-output examples.
Solver int count_passing_inputs(SketchFunction program, File file)
{
	int score = 0;
	int row_id = 0;
	int n = file.size();
    Input input;
    bool success;
	while(row_id < n){
	//for(int row_id = 0; row_id < file.size();i++){
	    input = file.get(row_id);
		success = program.passes(input);
		if(success == true){
		    score = score + 1;
		}
		row_id++;
	}
	print("count_passing_inputs returns", score);
	return score;
}
