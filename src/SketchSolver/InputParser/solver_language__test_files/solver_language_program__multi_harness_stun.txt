Solver concatenate(arr1, arr2)
{
    n = arr2.size();
    for(i = 0;i<n;i++)
    {
        arr1.append(arr2.get(i));
    }
}

/*
generator int line_generator(int x) {
    //USER DEFINED
};

generator bit predicate_generator(int x)
{
    //USER DEFINED
}

bit predicate(int x)
{
    return predicate_generator(x);
}

bit condition(int x) {return 0;}

int if_true_branch(int x) {return 0;}

int if_false_branch(int x) {return 0;}

int composite_predicate(int x) {
    if(condition(x)) {
        return if_true_branch(x);
    }
    else {
        return if_false_branch(x);
    }
}

bit program_lvl0(int x) {
    return line(x);
}

int dummy_program(int x) {return 1;}

@FromFile("zig_zag.data")
harness void sketch_main(int x, bit out)
{
    assert(dummy_program(x) == out);
}

@FromFile("zig_zag.data")
harness void eval_predicate_main(int x, bit out)
{
    bit one = 1;
    assert(dummy_program(x) == one);
}

@FromFile("zig_zag.data")
harness void dummy_sketch_main(int x, bit out)
{
    assert(program(x) == 0);
    assert(program_lvl0(x) == out);
    assert(composite_predicate(x) == out);
}
*/

Solver best_effort_programs(harness, file, num_trials, num_rows_per_sample)
{
    solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);
    programs = [];
    for(int i = 0;i<solutions.size();i++)
    {
        programs.append(pair<int, SketchFunction>(solutions.get(i).first(), harness.produce_concretization(solutions.get(i).second())));
    }
    return programs;
}

Solver main()
{
    return top_down_and_bottom_up_synthesis_sketch_main();
    //return left_and_right_and_cond_synthesis_sketch_main();
}

Solver synthesize_composite_programs_from_parts(left_programs, right_programs, select_best, file_name, num_trials, num_rows_per_sample)
{
    seed_main_lvl1 = [];

    for(int i = 0;i<select_best;i++) {
        for(int j = 0;i<select_best;i++) {
            predicate_lvl1 =
                composite_predicate.produce_replace("condition", predicate.clone());
            predicate_lvl1.replace("if_true_branch",
                program_lvl0.produce_concretization(left_programs.get(i).second().get_solution()));
            predicate_lvl1.replace("if_false_branch",
                program_lvl0.produce_concretization(right_programs.get(j).second().get_solution()));

            sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", predicate_lvl1);
            sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl1_sub);

            File file = File(file_name, sketch_main_lvl1);
            local_sketch_main_lvl1_programs = best_effort_programs(sketch_main_lvl1, file, num_trials, num_rows_per_sample);

            tmp = [];

            for(int k = 0; k < local_sketch_main_lvl1_programs.size();k++)
            {
                tmp.append(
                    pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                        local_sketch_main_lvl1_programs.get(i),
                        pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                            left_programs.get(i),
                            right_programs.get(j))));
            }

            local_sketch_main_lvl1_programs = tmp;

            concatenate(seed_main_lvl1, local_sketch_main_lvl1_programs);
        }
    }

    seed_main_lvl1.sort();
    seed_main_lvl1.reverse();

    assert(seed_main_lvl1.size() == (select_best*select_best), "FAILED: seed_main_lvl1.size() == (select_best*select_best)");

    return seed_main_lvl1;
}

Solver check_predicate_and_assertion_consistency(the_predicate, file_name, the_harness)
{
    File file_for_predicate = File(file_name, the_predicate);
    File file_for_harness = File(file_name, the_harness);
    for(int i = 0;i<file_for_predicate.size();i++) {
        //print("out", i, "(predicate)", the_predicate(file_for_predicate.get(i)), "(harness)", the_harness.passes(file_for_harness.get(i)));
        assert(the_predicate(file_for_predicate.get(i)) == the_harness.passes(file_for_harness.get(i)), "MISSMATCH AT: ", i);
    }
}

Solver top_down_and_bottom_up_synthesis_sketch_main()
{
    string file_name = "uav_kg_big__as_bools.data";
    //string file_name = "zig_zag.data";

    num_trials = 1;
    num_rows_per_sample = 1;
    select_best = 1;
    assert(num_trials >= select_best);

    sketch_main_lvl0_sub = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
    sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", sketch_main_lvl0_sub);

    File file = File(file_name, sketch_main_lvl0);
    left_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, num_trials, num_rows_per_sample);
    right_lvl0_programs = best_effort_programs(sketch_main_lvl0, file, num_trials, num_rows_per_sample);

    assert(left_lvl0_programs.size() >= select_best);
    assert(right_lvl0_programs.size() >= select_best);

    seed_main_lvl1 = synthesize_composite_programs_from_parts(left_lvl0_programs, right_lvl0_programs, select_best, file_name, num_trials, num_rows_per_sample);

    improved_main_lvl1 = [];

    int prev_best = 0-1;
    int new_best = seed_main_lvl1.get(0).first().first();


    num_trials = 3;
    num_rows_per_sample = 3;
    select_best = 2;
    assert(num_trials >= select_best);

    while(new_best > prev_best)
    {
        print("NEW_ITERATION");
        print("prev_best", prev_best, "new_best", new_best);

        prev_best = new_best;
        new_best = 0;

        for(int i = 0; i<seed_main_lvl1.size();i++)
        {
            improved_main_lvl1.append(seed_main_lvl1.get(i));
        }

        if(seed_main_lvl1.size() < select_best)
        {
            select_best = seed_main_lvl1.size();
        }

        assert(seed_main_lvl1.size() >= select_best, "FAILED: seed_main_lvl1.size() >= select_best");

        for(int i = 0;i<select_best;i++)
        {
            print("prev_score: ", seed_main_lvl1.get(i).first().first());
            local_program = seed_main_lvl1.get(i).first().second();
            //take condition
            condition_lvl1_sub_sub = predicate.produce_concretization(local_program.get_solution("condition"));
            condition_lvl1_sub = eval_predicate_main.produce_replace("dummy_predicate", condition_lvl1_sub_sub);
            condition_lvl1_sub_harness = eval_predicate_main_harness.produce_replace("eval_predicate_main", condition_lvl1_sub);
            condition_lvl1 = eval_predicate_main_harness__Wrapper.produce_replace("eval_predicate_main_harness", condition_lvl1_sub_harness);

            //run this to check consistency condition_lvl1 and condition_lvl1_sub
            //this makes sure that the function_call operation of sketches works as expected.
            check_predicate_and_assertion_consistency(condition_lvl1_sub, file_name, condition_lvl1);

            File file = File(file_name, condition_lvl1_sub);
            //split file based on condition
            if_true_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return condition_lvl1_sub(x);});
            if_false_file = file.produce_filter(lambda[condition_lvl1_sub](x){
                return not(condition_lvl1_sub(x));});

            print("if_true_file.size()", if_true_file.size());
            print("if_false_file.size()", if_false_file.size());

            if(if_true_file.size() >= num_rows_per_sample) {
                if(if_false_file.size() >= num_rows_per_sample) {
                    print("ENTER i", i);
                    assert(if_true_file.size() >= num_rows_per_sample, "FAILED: if_true_file.size() >= num_rows_per_sample");
                    assert(if_false_file.size() >= num_rows_per_sample, "FAILED: if_false_file.size() >= num_rows_per_sample");
                    assert((if_true_file.size()+if_false_file.size()) == file.size(), "FAILED: if_true_file.size()+if_false_file.size() == file.size()");

                    //resynthesize lvl0 left and right predicates.

                    left_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
                    left_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", left_tmp);
                    if_true_file.relabel(left_sketch_main_lvl0);
                    left_sketch_main_lvl0_programs = best_effort_programs(left_sketch_main_lvl0, if_true_file, num_trials, num_rows_per_sample);
                    left_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().first());
                    left_sketch_main_lvl0_programs.sort();
                    left_sketch_main_lvl0_programs.reverse();

                    right_tmp = sketch_main.produce_replace("dummy_program", program_lvl0.clone());
                    right_sketch_main_lvl0 = sketch_main__Wrapper.produce_replace("sketch_main", right_tmp);
                    if_false_file.relabel(right_sketch_main_lvl0);
                    right_sketch_main_lvl0_programs = best_effort_programs(right_sketch_main_lvl0, if_false_file, num_trials, num_rows_per_sample);
                    right_sketch_main_lvl0_programs.append(seed_main_lvl1.get(i).second().second());
                    right_sketch_main_lvl0_programs.sort();
                    right_sketch_main_lvl0_programs.reverse();

                    //combine with condition

                    new_best_predicate_lvl1 = composite_predicate.produce_replace("condition", condition_lvl1_sub_sub);
                    new_best_predicate_lvl1.replace("if_true_branch",
                        program_lvl0.produce_concretization(left_sketch_main_lvl0_programs.get(0).second().get_solution()));
                    new_best_predicate_lvl1.replace("if_false_branch",
                        program_lvl0.produce_concretization(right_sketch_main_lvl0_programs.get(0).second().get_solution()));

                    new_best_sketch_main_lvl1_sub = sketch_main.produce_replace("dummy_program", new_best_predicate_lvl1);
                    new_best_sketch_main_lvl1 = sketch_main__Wrapper.produce_replace("sketch_main", new_best_sketch_main_lvl1_sub);

                    file = File(file_name, new_best_sketch_main_lvl1);
                    int score = count_passing_inputs(new_best_sketch_main_lvl1, file);

                    print("new_score:", score);

                    improved_main_lvl1.append(
                        pair<pair<int, SketchFunction>, pair<pair<int, SketchFunction>, pair<int, SketchFunction> > >(
                            pair<int, SketchFunction>(score, new_best_sketch_main_lvl1),
                            pair<pair<int, SketchFunction>, pair<int, SketchFunction> >(
                                left_sketch_main_lvl0_programs.get(0),
                                right_sketch_main_lvl0_programs.get(0))));

                    //commented out in ordeer to test the existence of solutions in the very previous statement.
                    /*
                    new_synthesized_lvl1 =
                        synthesize_composite_programs_from_parts(
                            left_sketch_main_lvl0_programs, right_sketch_main_lvl0_programs,
                            select_best, file_name, num_trials, num_rows_per_sample);

                    print("synthesized_best_score: ", new_synthesized_lvl1.get(0).first().first());

                    concatenate(improved_main_lvl1, new_synthesized_lvl1);
                    */
                }
            }
        }

        improved_main_lvl1.sort();
        improved_main_lvl1.reverse();

        new_best = improved_main_lvl1.get(0).first().first();
        seed_main_lvl1 = improved_main_lvl1;
        improved_main_lvl1 = [];


        //num_trials=num_trials+2;
        //num_rows_per_sample++;
        //select_best++;
        assert(num_trials >= select_best);
    }

    assert(new_best == prev_best);

    assert(seed_main_lvl1.size() >= 1);

    return seed_main_lvl1.get(0).first().second();
}

Solver left_and_right_and_cond_synthesis_sketch_main()
{
    //first sample base level
    //choose best
    //sample left and right
    //choose best

    num_trials = 10;
    num_rows_per_sample = 6;
    select_best = 5;

    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";
    
    file = File(file_name, sketch_main_lvl0_left__Wrapper);
    lvl0_left_solutions = best_effort_solutions(sketch_main_lvl0_left__Wrapper, file, num_trials, num_rows_per_sample);

    file = File(file_name, sketch_main_lvl0_right__Wrapper);
    lvl0_right_solutions = best_effort_solutions(sketch_main_lvl0_right__Wrapper, file, num_trials, num_rows_per_sample);

    print("first lvl0_left_solutions.size() ", lvl0_left_solutions.size());
    print("first lvl0_right_solutions.size() ", lvl0_right_solutions.size());

    predicate_lvl0_left_original = predicate_lvl0_left.clone();
    predicate_lvl0_right_original = predicate_lvl0_right.clone();

    any ret;

    {
        all_compound_solutions = [];

        print("lvl0_left_solutions.size() ", lvl0_left_solutions.size());
        print("lvl0_right_solutions.size() ", lvl0_right_solutions.size());
        for(i = 0;i<select_best;i++)
        {
            predicate_lvl0_left.concretize(lvl0_left_solutions.get(i).second());
            for(j = 0;j<select_best; j++)
            {
                predicate_lvl0_right.concretize(lvl0_right_solutions.get(j).second());

                any compound_solutions;
                {
                    file = File(file_name, sketch_main_lvl1__Wrapper);
                    compound_solutions = best_effort_solutions(sketch_main_lvl1__Wrapper, file, num_trials, num_rows_per_sample);
                    //file.clear();
                }

                //this is not intuitive
                n_compound_solutions = compound_solutions.size();
                for(k = 0;k<n_compound_solutions; k++)
                {
                    compound_solutions.get(k).second().join(lvl0_left_solutions.get(i).second());
                    compound_solutions.get(k).second().join(lvl0_right_solutions.get(j).second());
                }

                concatenate(all_compound_solutions, compound_solutions);

                //predicate_lvl0_right.clear();
                predicate_lvl0_right = predicate_lvl0_right_original.clone();
            }

            //predicate_lvl0_left.clear();
            predicate_lvl0_left = predicate_lvl0_left_original.clone();
        }

        all_compound_solutions.sort();
        all_compound_solutions.reverse();

        ret = all_compound_solutions.get(0).second();
    }

    //predicate_lvl0_left.clear();
    predicate_lvl0_left = predicate_lvl0_left_original;
    //predicate_lvl0_right.clear();
    predicate_lvl0_right = predicate_lvl0_right_original;

    return ret;
}

Solver int get_score(SketchFunction harness, Solution solution, File file)
{
    SketchFunction program = harness.produce_concretization(solution); // create a program that uses the solution to fill in the holes of the harness.
    int score2 = count_passing_inputs(program, file); // count how many input-output examples are solved with this solution
    program.clear();
    return score2;
}

/*

Solver Solution original_sketch_main()
{
    return beam_search_sketch_main();
    //return repeat_greedy_sketch_main();
    //return stun_sketch_main("zig_zag.data");
}

Solver Solution beam_search_sketch_main()
{
    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";
    //string file_name = "uav_kg_big__as_bools__smaller.data";

    File file = File(file_name, sketch_main_lvl0__Wrapper); //unnatural, remove harness
    int total_num_rows = file.size();

    int num_trials = 10;
    int num_rows_per_sample = 6;
    int beam_breath = 3;

    vector<pair<int, Solution> > best_effort_solutions =
        best_effort_solutions(sketch_main_lvl0__Wrapper, file, num_trials, num_rows_per_sample);

    vector<pair<int, pair<int, Solution> > > indexed_solutions = vector<pair<int, pair<int, Solution> > >();
    //use python syntax for arrays

    int best_effort_solutions_size = best_effort_solutions.size();
    pair<int, Solution> element;
    for(int i = 0; i<best_effort_solutions_size; i++)
    {
        element = best_effort_solutions.get(i);
        indexed_solutions.append(
            pair<int, pair<int, Solution> >(
                element.first(), pair<int, Solution>(0, element.second())));
    }

    indexed_solutions.sort();
    indexed_solutions.reverse();

    int num_candidates = indexed_solutions.size();
    SketchFunction harness;
    vector<pair<int, pair<int, Solution> > > next_frontier = vector<pair<int, pair<int, Solution> > >();
    int local_n;
    int j;
    Solution tmp_solution;
    Solution partial_solution;
    SketchFunction throw_away;
    for(i = 0;i<beam_breath;i++)
    {
        harness = sketch_main_lvl1__Wrapper.clone();
        assert(indexed_solutions.get(i).second().first() == 0);
        partial_solution = indexed_solutions.get(i).second().second();
        harness.concretize(partial_solution);
        file = File(file_name, harness);
        best_effort_solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            next_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(1, tmp_solution)));
        }
        harness.clear();
    }


    next_frontier.sort();
    next_frontier.reverse();


    num_candidates = next_frontier.size();
    vector<pair<int, pair<int, Solution> > > final_frontier = vector<pair<int, pair<int, Solution> > >();
    int counter = 0;
    for(i = 0;i<beam_breath;i++)
    {
        harness = sketch_main_lvl2__Wrapper.clone();
        assert(next_frontier.get(i).second().first() == 1);
        partial_solution = next_frontier.get(i).second().second();
        harness.concretize(partial_solution);
        file = File(file_name, harness);
        best_effort_solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            final_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(2, tmp_solution)));
            counter++;
            print("score ", best_effort_solutions.get(j).first(), " counter ", counter);
        }
        harness.clear();
    }

    final_frontier.sort();
    final_frontier.reverse();

    assert(final_frontier.size() > 0);

    Solution ret_solution = final_frontier.get(0).second().second();

    return ret_solution;
}

Solver Solution repeat_greedy_sketch_main()
{
    string file_name = "zig_zag.data";
    File file = File(file_name, sketch_main_lvl2__Wrapper);
    int n = file.size();


    Solution sol = stun_sketch_main(file_name);
    int score = get_score(sketch_main_lvl2__Wrapper, sol, file);
    print("at_score ", score, "/", n);
    while(score < n)
    {
        seed++;
        sol = stun_sketch_main(file_name);
        score = get_score(sketch_main_lvl2__Wrapper, sol, file);
        print("at_score ", score, "/", n);
    }

    return sol;
}

Solver Solution stun_sketch_main(string file_name)
{
	int num_trials = 3; //hyperparameter
	int num_rows = 4; //hyperparameter

    Solution total_solution = Solution();

    SketchFunction org_line_lvl0 = line_lvl0.clone();
    SketchFunction org_line_lvl1 = line_lvl1.clone();
    SketchFunction org_line_lvl2 = line_lvl2.clone();

	//solve the harness lvl0
	File file = File(file_name, sketch_main_lvl0__Wrapper); // The dataset is stored in a File; File is a native construct.
	print("sketch_main_lvl0__Wrapper.num_holes() = ", sketch_main_lvl0__Wrapper.num_holes());
	Solution solution_lvl0 = best_effort_synthesis(sketch_main_lvl0__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl0);

	//concretize the predicate lvl0
	line_lvl0.concretize(solution_lvl0);

	//solve the harness lvl1
	file = File(file_name, sketch_main_lvl1__Wrapper);
	print("sketch_main_lvl1__Wrapper.num_holes() = ", sketch_main_lvl1__Wrapper.num_holes());
	Solution solution_lvl1 = best_effort_synthesis(sketch_main_lvl1__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl1);

	//concretize the predicate lvl1
	line_lvl1.concretize(solution_lvl1);

	//solve the harness lvl2
	file = File(file_name, sketch_main_lvl2__Wrapper);
	print("sketch_main_lvl2__Wrapper.num_holes() = ", sketch_main_lvl2__Wrapper.num_holes());
	Solution solution_lvl2 = best_effort_synthesis(sketch_main_lvl2__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl2);

	//concretize the predicate lvl2
	line_lvl2.concretize(solution_lvl2);

	//done, no more predicates to concretize.

    line_lvl0 = org_line_lvl0.clone();
    line_lvl1 = org_line_lvl1.clone();
    line_lvl2 = org_line_lvl2.clone();

	return total_solution;
}

*/

Solver best_effort_solutions(SketchFunction harness, File file, int num_trials, int num_rows) {
	Solution best_solution;
	int best_score = 0;

    File subset_file;
    Solution solution;
    SketchFunction program;
    int score;
    vector<pair<int, Solution> > solutions = vector<pair<int, Solution> >();
    for(int trial_id = 0; trial_id<num_trials; trial_id++)
	{
		subset_file = file.produce_subset_file(num_rows); //sample subset of the rows
		solution = SATSolver(harness, subset_file); // invoke the Sketch Solver on the harness
		subset_file.clear();
		score = get_score(harness, solution, file);
		solutions.append(pair<int, Solution>(score, solution));
		if(score > best_score) // update the best_solution
		{
			best_solution = solution;
			best_score = score;
		}
	}

	solutions.sort();
	solutions.reverse();

	print("Sorted solution scores:");

	int solutions_size = solutions.size();

    pair<int, Solution> element;
	for(int i = 0; i<solutions_size; i++)
	{
	    element = solutions.get(i);
	    print("count ", element.first(), "/", file.size(), "= (", ((float(100) * float(element.first())) / float(file.size())), "%)");
	}
	print("Done sorted solution scores");

	print("best_score = ", best_score);

    assert(solutions.size() == num_trials);

    print("ASSERTED TRUE:", "solutions.size()", solutions.size(), "num_trials", num_trials);

    return solutions;
}

/*

Solver Solution best_effort_synthesis(SketchFunction harness, File file, int num_trials, int num_rows) {
    vector<pair<int, Solution> > solutions = best_effort_solutions(harness, file, num_trials, num_rows);
    int solutions_size = solutions.size();
    Solution ret = solutions.get(0).second();
	return ret;
}

*/

//subroutine to count the number of passing input-output examples.
Solver int count_passing_inputs(SketchFunction program, File file)
{
	int score = 0;
	int row_id = 0;
	int n = file.size();
    Input input;
    bool success;
	while(row_id < n){
	//for(int row_id = 0; row_id < file.size();i++){
	    input = file.get(row_id);
		success = program.passes(input);
		if(success == true){
		    score = score + 1;
		}
		row_id++;
	}
	return score;
}
