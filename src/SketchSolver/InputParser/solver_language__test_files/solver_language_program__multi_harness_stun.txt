Solver concatenate(arr1, arr2)
{
    n = arr2.size();
    for(i = 0;i<n;i++)
    {
        arr1.append(arr2.get(i));
    }
}

/*
generator bit predicate_generator(Data data)
{
    ..
}

bit template_predicate_lvl0(Data data)
{
    return predicate_generator(data);
}

bit composite_predicate(Data data)
{
    if(condition(data))
    {
        return left_predicate(data);
    }
    else
    {
        return right_predicate(data);
    }
}

@FromFile("uav_kg_big__as_bools.data")
harness template_main(Data data, bit out)
{
    assert(program(data) == out);
}
*/

Solver best_effort_programs(harness, file, num_trials, num_rows_per_sample)
{
    solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);
    programs = [];
    for(int i = 0;i<solutions.size();i++)
    {
        programs.append(pair<int, SketchFunction>(solutions.get(i).first(), harness.produce_concretization(solutions.get(i).second())));
    }
    return programs;
}

Solver main()
{
    return top_down_and_bottom_up_synthesis_main();
    //return left_and_right_and_cond_synthesis_main();
}

Solver top_down_and_bottom_up_synthesis_main()
{
    //generate

    string file_name = "uav_kg_big__as_bools.data";

    num_trials = 30;
    num_rows_per_sample = 6;
    select_best = 8;
    assert(select_best >= 2);
    assert(num_trials >= select_best);

    main_lvl0_sub = template_main.produce_replace("program", template_predicate_lvl0.clone());
    //main_lvl0 = main_lvl0_sub;
    main_lvl0 = template_main__Wrapper.produce_replace("template_main", main_lvl0_sub);


    File file = File(file_name, main_lvl0);
    main_lvl0_programs = best_effort_programs(main_lvl0, file, num_trials, num_rows_per_sample);

    assert(main_lvl0_programs.size() >= select_best);

    all_main_lvl1_programs = [];

    for(int i = 0;i<select_best;i++) {
        for(int j = i+1;i<select_best;i++) {
            predicate_lvl1 =
                composite_predicate.produce_replace("condition", template_predicate_lvl0.clone());
            predicate_lvl1.replace("left_predicate",
                template_predicate_lvl0.produce_concretization(main_lvl0_programs.get(i).second().get_solution()));
            predicate_lvl1.replace("right_predicate",
                template_predicate_lvl0.produce_concretization(main_lvl0_programs.get(j).second().get_solution()));

            main_lvl1_sub = template_main.produce_replace("program", predicate_lvl1);
            main_lvl1 = template_main__Wrapper.produce_replace("template_main", main_lvl1_sub);

            File file = File(file_name, main_lvl1);
            local_main_lvl1_programs = best_effort_programs(main_lvl1, file, num_trials, num_rows_per_sample);

            concatenate(all_main_lvl1_programs, local_main_lvl1_programs);
        }
    }

    all_main_lvl1_programs.sort();
    all_main_lvl1_programs.reverse();

    improved_main_lvl1 = [];

    for(int i = 0;i<select_best;i++)
    {
        local_program = all_main_lvl1_programs.get(i).second();
        //take condition
        condition_lvl1_sub_sub = template_predicate_lvl0.produce_concretization(local_program.get_solution());
        condition_lvl1_sub = template_eval_main.produce_replace("program", condition_lvl1_sub_sub);
        condition_lvl1 = template_eval_main__Wrapper.produce_replace("template_eval_main", condition_lvl1_sub);
        File file = File(file_name, condition_lvl1);
        //split file based on condition

        if_true_file = file.produce_filter(lambda[condition_lvl1](x){return condition_lvl1.passes(x);});
        if_false_file = file.produce_filter(lambda[condition_lvl1](x){return not(condition_lvl1.passes(x));});

        print("if_true_file.size()", if_true_file.size());
        print("if_false_file.size()", if_false_file.size());

        if(if_true_file.size() >= num_rows_per_sample) {
            if(if_false_file.size() >= num_rows_per_sample) {
                assert(if_true_file.size() >= num_rows_per_sample, "FAILED: if_true_file.size() >= num_rows_per_sample");
                assert(if_false_file.size() >= num_rows_per_sample, "FAILED: if_false_file.size() >= num_rows_per_sample");
                assert((if_true_file.size()+if_false_file.size()) == file.size(), "FAILED: if_true_file.size()+if_false_file.size() == file.size()");

                //resynthesize lvl0 left and right predicates.

                left_tmp = template_main.produce_replace("program", template_predicate_lvl0.clone());
                left_main_lvl0 = template_main__Wrapper.produce_replace("template_main", left_tmp);
                if_true_file.relabel(left_main_lvl0);
                left_main_lvl1_programs = best_effort_programs(left_main_lvl0, if_true_file, num_trials, num_rows_per_sample);

                right_tmp = template_main.produce_replace("program", template_predicate_lvl0.clone());
                right_main_lvl0 = template_main__Wrapper.produce_replace("template_main", right_tmp);
                if_false_file.relabel(right_main_lvl0);
                right_main_lvl1_programs = best_effort_programs(right_main_lvl0, if_false_file, num_trials, num_rows_per_sample);

                //combine with condition

                new_best_predicate_lvl1 = composite_predicate.produce_replace("condition", condition_lvl1_sub_sub);
                new_best_predicate_lvl1.replace("left_predicate",
                    template_predicate_lvl0.produce_concretization(left_main_lvl1_programs.get(0).second().get_solution()));
                new_best_predicate_lvl1.replace("right_predicate",
                    template_predicate_lvl0.produce_concretization(right_main_lvl1_programs.get(0).second().get_solution()));

                new_best_main_lvl1_sub = template_main.produce_replace("program", new_best_predicate_lvl1);
                new_best_main_lvl1 = template_main__Wrapper.produce_replace("template_main", new_best_main_lvl1_sub);


                file = File(file_name, new_best_main_lvl1);
                int score = count_passing_inputs(new_best_main_lvl1, file);

                print("new_score:", score);

                improved_main_lvl1.append(pair<int, SketchFunction>(score, new_best_main_lvl1));
            }
        }

    }

    improved_main_lvl1.sort();
    improved_main_lvl1.reverse();

    return improved_main_lvl1.get(0).second();
}

Solver left_and_right_and_cond_synthesis_main()
{
    //first sample base level
    //choose best
    //sample left and right
    //choose best

    num_trials = 10;
    num_rows_per_sample = 6;
    select_best = 5;

    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";

    file = File(file_name, main_lvl0_left__Wrapper);
    lvl0_left_solutions = best_effort_solutions(main_lvl0_left__Wrapper, file, num_trials, num_rows_per_sample);

    file = File(file_name, main_lvl0_right__Wrapper);
    lvl0_right_solutions = best_effort_solutions(main_lvl0_right__Wrapper, file, num_trials, num_rows_per_sample);

    print("first lvl0_left_solutions.size() ", lvl0_left_solutions.size());
    print("first lvl0_right_solutions.size() ", lvl0_right_solutions.size());

    predicate_lvl0_left_original = predicate_lvl0_left.clone();
    predicate_lvl0_right_original = predicate_lvl0_right.clone();

    any ret;

    {
        all_compound_solutions = [];

        print("lvl0_left_solutions.size() ", lvl0_left_solutions.size());
        print("lvl0_right_solutions.size() ", lvl0_right_solutions.size());
        for(i = 0;i<select_best;i++)
        {
            predicate_lvl0_left.concretize(lvl0_left_solutions.get(i).second());
            for(j = 0;j<select_best; j++)
            {
                predicate_lvl0_right.concretize(lvl0_right_solutions.get(j).second());

                any compound_solutions;
                {
                    file = File(file_name, main_lvl1__Wrapper);
                    compound_solutions = best_effort_solutions(main_lvl1__Wrapper, file, num_trials, num_rows_per_sample);
                    //file.clear();
                }

                //this is not intuitive
                n_compound_solutions = compound_solutions.size();
                for(k = 0;k<n_compound_solutions; k++)
                {
                    compound_solutions.get(k).second().join(lvl0_left_solutions.get(i).second());
                    compound_solutions.get(k).second().join(lvl0_right_solutions.get(j).second());
                }

                concatenate(all_compound_solutions, compound_solutions);

                //predicate_lvl0_right.clear();
                predicate_lvl0_right = predicate_lvl0_right_original.clone();
            }

            //predicate_lvl0_left.clear();
            predicate_lvl0_left = predicate_lvl0_left_original.clone();
        }

        all_compound_solutions.sort();
        all_compound_solutions.reverse();

        ret = all_compound_solutions.get(0).second();
    }

    //predicate_lvl0_left.clear();
    predicate_lvl0_left = predicate_lvl0_left_original;
    //predicate_lvl0_right.clear();
    predicate_lvl0_right = predicate_lvl0_right_original;

    return ret;
}

Solver int get_score(SketchFunction harness, Solution solution, File file)
{
    SketchFunction program = harness.produce_concretization(solution); // create a program that uses the solution to fill in the holes of the harness.
    int score2 = count_passing_inputs(program, file); // count how many input-output examples are solved with this solution
    program.clear();
    return score2;
}

/*

Solver Solution original_main()
{
    return beam_search_main();
    //return repeat_greedy_main();
    //return stun_main("zig_zag.data");
}

Solver Solution beam_search_main()
{
    //string file_name = "zig_zag.data";
    string file_name = "uav_kg_big__as_bools.data";
    //string file_name = "uav_kg_big__as_bools__smaller.data";

    File file = File(file_name, main_lvl0__Wrapper); //unnatural, remove harness
    int total_num_rows = file.size();

    int num_trials = 10;
    int num_rows_per_sample = 6;
    int beam_breath = 3;

    vector<pair<int, Solution> > best_effort_solutions =
        best_effort_solutions(main_lvl0__Wrapper, file, num_trials, num_rows_per_sample);

    vector<pair<int, pair<int, Solution> > > indexed_solutions = vector<pair<int, pair<int, Solution> > >();
    //use python syntax for arrays

    int best_effort_solutions_size = best_effort_solutions.size();
    pair<int, Solution> element;
    for(int i = 0; i<best_effort_solutions_size; i++)
    {
        element = best_effort_solutions.get(i);
        indexed_solutions.append(
            pair<int, pair<int, Solution> >(
                element.first(), pair<int, Solution>(0, element.second())));
    }

    indexed_solutions.sort();
    indexed_solutions.reverse();

    int num_candidates = indexed_solutions.size();
    SketchFunction harness;
    vector<pair<int, pair<int, Solution> > > next_frontier = vector<pair<int, pair<int, Solution> > >();
    int local_n;
    int j;
    Solution tmp_solution;
    Solution partial_solution;
    SketchFunction throw_away;
    for(i = 0;i<beam_breath;i++)
    {
        harness = main_lvl1__Wrapper.clone();
        assert(indexed_solutions.get(i).second().first() == 0);
        partial_solution = indexed_solutions.get(i).second().second();
        harness.concretize(partial_solution);
        file = File(file_name, harness);
        best_effort_solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            next_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(1, tmp_solution)));
        }
        harness.clear();
    }


    next_frontier.sort();
    next_frontier.reverse();


    num_candidates = next_frontier.size();
    vector<pair<int, pair<int, Solution> > > final_frontier = vector<pair<int, pair<int, Solution> > >();
    int counter = 0;
    for(i = 0;i<beam_breath;i++)
    {
        harness = main_lvl2__Wrapper.clone();
        assert(next_frontier.get(i).second().first() == 1);
        partial_solution = next_frontier.get(i).second().second();
        harness.concretize(partial_solution);
        file = File(file_name, harness);
        best_effort_solutions = best_effort_solutions(harness, file, num_trials, num_rows_per_sample);

        local_n = best_effort_solutions.size();

        for(j = 0;j<local_n;j++)
        {
            tmp_solution = partial_solution.clone();
            tmp_solution.join(best_effort_solutions.get(j).second());
            final_frontier.append(
                pair<int, pair<int, Solution> >(
                    best_effort_solutions.get(j).first(),
                    pair<int, Solution>(2, tmp_solution)));
            counter++;
            print("score ", best_effort_solutions.get(j).first(), " counter ", counter);
        }
        harness.clear();
    }

    final_frontier.sort();
    final_frontier.reverse();

    assert(final_frontier.size() > 0);

    Solution ret_solution = final_frontier.get(0).second().second();

    return ret_solution;
}

Solver Solution repeat_greedy_main()
{
    string file_name = "zig_zag.data";
    File file = File(file_name, main_lvl2__Wrapper);
    int n = file.size();


    Solution sol = stun_main(file_name);
    int score = get_score(main_lvl2__Wrapper, sol, file);
    print("at_score ", score, "/", n);
    while(score < n)
    {
        seed++;
        sol = stun_main(file_name);
        score = get_score(main_lvl2__Wrapper, sol, file);
        print("at_score ", score, "/", n);
    }

    return sol;
}

Solver Solution stun_main(string file_name)
{
	int num_trials = 3; //hyperparameter
	int num_rows = 4; //hyperparameter

    Solution total_solution = Solution();

    SketchFunction org_line_lvl0 = line_lvl0.clone();
    SketchFunction org_line_lvl1 = line_lvl1.clone();
    SketchFunction org_line_lvl2 = line_lvl2.clone();

	//solve the harness lvl0
	File file = File(file_name, main_lvl0__Wrapper); // The dataset is stored in a File; File is a native construct.
	print("main_lvl0__Wrapper.num_holes() = ", main_lvl0__Wrapper.num_holes());
	Solution solution_lvl0 = best_effort_synthesis(main_lvl0__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl0);

	//concretize the predicate lvl0
	line_lvl0.concretize(solution_lvl0);

	//solve the harness lvl1
	file = File(file_name, main_lvl1__Wrapper);
	print("main_lvl1__Wrapper.num_holes() = ", main_lvl1__Wrapper.num_holes());
	Solution solution_lvl1 = best_effort_synthesis(main_lvl1__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl1);

	//concretize the predicate lvl1
	line_lvl1.concretize(solution_lvl1);

	//solve the harness lvl2
	file = File(file_name, main_lvl2__Wrapper);
	print("main_lvl2__Wrapper.num_holes() = ", main_lvl2__Wrapper.num_holes());
	Solution solution_lvl2 = best_effort_synthesis(main_lvl2__Wrapper, file, num_trials, num_rows);
    total_solution.join(solution_lvl2);

	//concretize the predicate lvl2
	line_lvl2.concretize(solution_lvl2);

	//done, no more predicates to concretize.

    line_lvl0 = org_line_lvl0.clone();
    line_lvl1 = org_line_lvl1.clone();
    line_lvl2 = org_line_lvl2.clone();

	return total_solution;
}

*/

Solver best_effort_solutions(SketchFunction harness, File file, int num_trials, int num_rows) {
	Solution best_solution;
	int best_score = 0;

    File subset_file;
    Solution solution;
    SketchFunction program;
    int score;
    vector<pair<int, Solution> > solutions = vector<pair<int, Solution> >();
    for(int trial_id = 0; trial_id<num_trials; trial_id++)
	{
		subset_file = file.produce_subset_file(num_rows); //sample subset of the rows
		solution = SATSolver(harness, subset_file); // invoke the Sketch Solver on the harness
		subset_file.clear();
		score = get_score(harness, solution, file);
		solutions.append(pair<int, Solution>(score, solution));
		if(score > best_score) // update the best_solution
		{
			best_solution = solution;
			best_score = score;
		}
	}

	solutions.sort();
	solutions.reverse();

	print("Sorted solution scores:");

	int solutions_size = solutions.size();

    pair<int, Solution> element;
	for(int i = 0; i<solutions_size; i++)
	{
	    element = solutions.get(i);
	    print("count ", element.first(), "/", file.size(), "= (", ((float(100) * float(element.first())) / float(file.size())), "%)");
	}
	print("Done sorted solution scores");

	print("best_score = ", best_score);

    assert(solutions.size() == num_trials);

    print("ASSERTED TRUE:", "solutions.size()", solutions.size(), "num_trials", num_trials);

    return solutions;
}

/*

Solver Solution best_effort_synthesis(SketchFunction harness, File file, int num_trials, int num_rows) {
    vector<pair<int, Solution> > solutions = best_effort_solutions(harness, file, num_trials, num_rows);
    int solutions_size = solutions.size();
    Solution ret = solutions.get(0).second();
	return ret;
}

*/

//subroutine to count the number of passing input-output examples.
Solver int count_passing_inputs(SketchFunction program, File file)
{
	int score = 0;
	int row_id = 0;
	int n = file.size();
    Input input;
    bool success;
	while(row_id < n){
	//for(int row_id = 0; row_id < file.size();i++){
	    input = file.get(row_id);
		success = program.passes(input);
		if(success == true){
		    score = score + 1;
		}
		row_id++;
	}
	return score;
}
